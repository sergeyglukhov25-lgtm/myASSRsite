/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t2 = exports.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R2++;
      debug(name, index, value);
      t2[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a2, b2) => {
      if (typeof a2 === "number" && typeof b2 === "number") {
        return a2 === b2 ? 0 : a2 < b2 ? -1 : 1;
      }
      const anum = numeric.test(a2);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a2 = +a2;
        b2 = +b2;
      }
      return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a2, b2) => compareIdentifiers(b2, a2);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t: t2 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a2 = this.prerelease[i2];
          const b2 = other.prerelease[i2];
          debug("prerelease compare", i2, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a2 = this.build[i2];
          const b2 = other.build[i2];
          debug("build compare", i2, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t2.PRERELEASELOOSE] : re[t2.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v2 = parse(version, options);
      return v2 ? v2.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    "use strict";
    var parse = require_parse();
    var clean = (version, options) => {
      const s2 = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a2, loose) => new SemVer(a2, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a2, loose) => new SemVer(a2, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a2, loose) => new SemVer(a2, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a2, b2, loose) => compare(b2, a2, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a2, b2) => compare(a2, b2, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a2, b2, loose) => {
      const versionA = new SemVer(a2, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a2, b2) => compareBuild(a2, b2, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a2, b2) => compareBuild(b2, a2, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a2, b2, loose) => compare(a2, b2, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a2, b2, loose) => compare(a2, b2, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a2, b2, loose) => compare(a2, b2, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a2, b2, loose) => compare(a2, b2, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a2, b2, loose) => compare(a2, b2, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a2, b2, loose) => compare(a2, b2, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a2, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 === b2;
        case "!==":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 !== b2;
        case "":
        case "=":
        case "==":
          return eq(a2, b2, loose);
        case "!=":
          return neq(a2, b2, loose);
        case ">":
          return gt(a2, b2, loose);
        case ">=":
          return gte(a2, b2, loose);
        case "<":
          return lt(a2, b2, loose);
        case "<=":
          return lte(a2, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t: t2 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t2.COERCEFULL] : re[t2.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t2.COERCERTLFULL] : re[t2.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (i2 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i2];
            for (let k2 = 0; k2 < comps.length; k2++) {
              if (k2 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k2].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t2.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t2.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t2.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t2,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c2) => c2.value === "<0.0.0-0";
    var isAny = (c2) => c2.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t2.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r2 = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
      return comp.replace(r2, (_2, M2, m2, p2, pr) => {
        debug("tilde", comp, _2, M2, m2, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.${p2} <${M2}.${+m2 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r2 = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_2, M2, m2, p2, pr) => {
        debug("caret", comp, _2, M2, m2, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M2 === "0") {
            ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p2} <${+M2 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r2 = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
      return comp.replace(r2, (ret, gtlt, M2, m2, p2, pr) => {
        debug("xRange", comp, ret, gtlt, M2, m2, p2, pr);
        const xM = isX(M2);
        const xm = xM || isX(m2);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M2 = +M2 + 1;
              m2 = 0;
              p2 = 0;
            } else {
              m2 = +m2 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M2 = +M2 + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M2}.${m2}.${p2}${pr}`;
        } else if (xm) {
          ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t2.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version, options) => {
      for (let i2 = 0; i2 < set2.length; i2++) {
        if (!set2[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set2.length; i2++) {
          debug(set2[i2].semver);
          if (set2[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i2].semver.prerelease.length > 0) {
            const allowed = set2[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
        const m2 = comp.match(r2);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t2 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max || maxSV.compare(v2) === -1) {
            max = v2;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min || minSV.compare(v2) === 1) {
            min = v2;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i2 = 0; i2 < range.set.length; ++i2) {
        const comparators = range.set[i2];
        let setMin2 = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin2 || gt(compver, setMin2)) {
                setMin2 = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin2 && (!minver || gt(minver, setMin2))) {
          minver = setMin2;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i2 = 0; i2 < range.set.length; ++i2) {
        const comparators = range.set[i2];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v2 = versions.sort((a2, b2) => compare(a2, b2, options));
      for (const version of v2) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v2[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v2[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c2 of sub) {
        if (c2.operator === ">" || c2.operator === ">=") {
          gt = higherGT(gt, c2, options);
        } else if (c2.operator === "<" || c2.operator === "<=") {
          lt = lowerLT(lt, c2, options);
        } else {
          eqSet.add(c2.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c2 of dom) {
          if (!satisfies(eq, String(c2), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c2 of dom) {
        hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
        hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c2.operator === ">" || c2.operator === ">=") {
            higher = higherGT(gt, c2, options);
            if (higher === c2 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c2), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c2.operator === "<" || c2.operator === "<=") {
            lower = lowerLT(lt, c2, options);
            if (lower === c2 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c2), options)) {
            return false;
          }
        }
        if (!c2.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
    };
    var lowerLT = (a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HeadingShifter
});
module.exports = __toCommonJS(main_exports);

// node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = true ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (true) {
    const e2 = errors[error];
    const msg = typeof e2 === "function" ? e2.apply(null, args) : e2;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value);
  else if (t2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return __spreadValues({}, base);
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: { value: dontMutateFrozenCollections },
      add: { value: dontMutateFrozenCollections },
      clear: { value: dontMutateFrozenCollections },
      delete: { value: dontMutateFrozenCollections }
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
          patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;

// src/utils/object.ts
var assignUnknownObjectFromDefaultObject = (defaultObject, targetObject) => {
  const newObj = structuredClone(targetObject);
  Object.entries(defaultObject).forEach(([k2, v2]) => {
    if (v2 === null) {
      return;
    }
    if (isPlainRecord(v2)) {
      const newTargetObject = newObj[k2];
      if (isPlainRecord(newTargetObject)) {
        newObj[k2] = assignUnknownObjectFromDefaultObject(v2, newTargetObject);
      } else {
        newObj[k2] = v2;
      }
      return;
    }
    if (newObj[k2] === null || newObj[k2] === void 0) {
      newObj[k2] = v2;
      return;
    }
  });
  return newObj;
};
function isPlainRecord(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Array.isArray(value) || value instanceof Map || value instanceof Set) {
    return false;
  }
  for (const key in value) {
    if (typeof key !== "string") {
      return false;
    }
  }
  return true;
}
var isObject = (obj) => {
  return typeof obj === "object" && obj !== null;
};
var carryOverCompatibleProps = (target, source) => {
  const result = {};
  for (const key in target) {
    if (Object.hasOwn(source, key)) {
      const sourceValue = source[key];
      if (typeof target[key] === typeof sourceValue) {
        result[key] = sourceValue;
      }
    }
  }
  return result;
};

// src/migrations/versions/1.9.0.ts
var DEFAULT_SETTINGS_1_9_0 = {
  version: "1.9.0",
  limitHeadingFrom: 1,
  overrideTab: false,
  styleToRemove: {
    beginning: { ul: true, ol: true, userDefined: [] },
    surrounding: { bold: false, italic: false, userDefined: [] }
  },
  autoOutdent: {
    enable: true,
    hotKey: {
      key: "Tab",
      shift: true,
      ctrl: false,
      alt: false
    }
  },
  autoIndentBulletedHeader: false
};
var settings_1_9_0 = {
  oldDefaultSettings: { version: "0.0.0" },
  defaultSettings: DEFAULT_SETTINGS_1_9_0,
  migration: () => DEFAULT_SETTINGS_1_9_0
};

// src/migrations/versions/1.10.0.ts
var DEFAULT_SETTINGS_1_10_0 = {
  version: "1.10.0",
  limitHeadingFrom: 1,
  overrideTab: false,
  styleToRemove: {
    beginning: { ul: true, ol: true, userDefined: [] },
    surrounding: { bold: false, italic: false, userDefined: [] }
  },
  list: { childrenBehavior: "outdent to zero" },
  editor: {
    tabSize: 4
  }
};
var migration_1_10_0 = (oldSettings) => {
  const compatibleSettings = carryOverCompatibleProps(
    DEFAULT_SETTINGS_1_10_0,
    oldSettings
  );
  const newSettings = __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_SETTINGS_1_10_0), compatibleSettings), {
    list: {
      childrenBehavior: oldSettings.autoIndentBulletedHeader ? "sync with headings" : oldSettings.autoOutdent.enable ? "outdent to zero" : "noting"
    },
    version: "1.10.0"
  });
  return newSettings;
};
var settings_1_10_0 = {
  defaultSettings: DEFAULT_SETTINGS_1_10_0,
  oldDefaultSettings: settings_1_9_0.defaultSettings,
  migration: migration_1_10_0
};

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types/type.ts
var HEADINGS = [0, 1, 2, 3, 4, 5, 6];

// src/settings.ts
var DEFAULT_SETTINGS = settings_1_10_0.defaultSettings;
var HeadingShifterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Lower limit of Heading").setDesc(
      "The lower Heading Size that will be decreased by the Heading Shift "
    ).addDropdown((dropdown) => {
      const headingOptions = HEADINGS.reduce(
        (prev, heading) => {
          prev[heading] = String(heading);
          return prev;
        },
        {}
      );
      dropdown.addOptions(headingOptions).setValue(String(this.plugin.settings.limitHeadingFrom)).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.limitHeadingFrom = Number(value);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Enable override tab behavior").setDesc(
      'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"'
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.overrideTab).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.overrideTab = value;
        yield this.plugin.saveSettings();
      }))
    );
    containerEl.createEl("h3", { text: "Style to remove" });
    containerEl.createEl("p", {
      text: "If this style is at the <position> of a line, remove it"
    });
    containerEl.createEl("b", { text: "Beginning" });
    new import_obsidian.Setting(containerEl).setName("Unordered list").setDesc("-").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.plugin.settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ul).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.styleToRemove.beginning.ul = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
    new import_obsidian.Setting(containerEl).setName("Ordered list").setDesc("1., 2. ,3. ,...").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.plugin.settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ol).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.styleToRemove.beginning.ol = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
    new import_obsidian.Setting(containerEl).setName("User defined").setDesc("Arbitrary string (regular expression)").addTextArea((str) => {
      var _a, _b;
      str.setValue(
        (_b = (_a = this.plugin.settings.styleToRemove.beginning) == null ? void 0 : _a.userDefined) == null ? void 0 : _b.join(
          "\n"
        )
      ).onChange((str2) => __async(this, null, function* () {
        this.plugin.settings.styleToRemove.beginning.userDefined = str2.split("\n");
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("b", {
      text: "Surrounding"
    });
    new import_obsidian.Setting(containerEl).setName("Bold").setDesc("**|__").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.plugin.settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.bold).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.styleToRemove.surrounding.bold = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
    new import_obsidian.Setting(containerEl).setName("Italic").setDesc("*|_").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.plugin.settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.italic).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.styleToRemove.surrounding.italic = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
    new import_obsidian.Setting(containerEl).setName("User defined").setDesc("Arbitrary string (regular expression)").addTextArea((str) => {
      var _a, _b, _c;
      str.setValue(
        (_c = (_b = (_a = this.plugin.settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.userDefined) == null ? void 0 : _c.join(
          "\n"
        )
      ).onChange((str2) => __async(this, null, function* () {
        this.plugin.settings.styleToRemove.surrounding.userDefined = str2.split("\n");
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h3", { text: "List" });
    new import_obsidian.Setting(containerEl).setName("Children behavior").addDropdown((dropdown) => {
      dropdown.addOption("outdent to zero", "Outdent to 0").addOption(
        "sync with headings",
        "Sync with headings"
      ).addOption("noting", "Noting").setValue(this.plugin.settings.list.childrenBehavior).onChange((v2) => {
        this.plugin.settings.list.childrenBehavior = v2;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", {
      text: "Editor"
    });
    new import_obsidian.Setting(containerEl).setName("Tab size").addSlider((cb) => {
      cb.setDynamicTooltip().setLimits(2, 8, 2).setValue(this.plugin.settings.editor.tabSize).onChange((v2) => {
        this.plugin.settings.editor.tabSize = v2;
        this.plugin.saveSettings();
      });
    });
  }
};

// src/migrations/migration.ts
var import_semver = __toESM(require_semver2(), 1);
var BASE_VERSION = "1.9.0";
var migrateSettings = ({
  settings: rawSettings,
  latestVersion,
  migrationObject
}) => {
  if (!isObject(rawSettings)) {
    return DEFAULT_SETTINGS;
  }
  const currentVersion = "version" in rawSettings && typeof rawSettings.version === "string" ? rawSettings.version : BASE_VERSION;
  if (import_semver.default.gt(currentVersion, latestVersion)) {
    const merged = assignUnknownObjectFromDefaultObject(
      DEFAULT_SETTINGS,
      rawSettings
    );
    return produce(merged, (draft) => {
      draft.version = latestVersion;
    });
  }
  const migrationVersions = Object.entries(migrationObject).filter(([k2]) => import_semver.default.gt(k2, currentVersion)).sort((a2, b2) => import_semver.default.compare(a2[0], b2[0]));
  const migratedSettings = migrationVersions.reduce(
    (accSettings, [_version, settingObj]) => {
      const mergedOld = assignUnknownObjectFromDefaultObject(
        settingObj.oldDefaultSettings,
        accSettings.settings
      );
      const newSettings = settingObj.migration(mergedOld);
      return {
        settings: newSettings,
        default: settingObj.defaultSettings
      };
    },
    { default: rawSettings, settings: rawSettings }
  );
  return migratedSettings.settings;
};

// src/migrations/type.ts
var MIGRATION_OBJECT = {
  "1.10.0": settings_1_10_0
};

// src/main.ts
var import_obsidian6 = require("obsidian");

// src/services/interfaceService.ts
var import_obsidian2 = require("obsidian");

// src/ui/icon.ts
var icon_increase_heading = `
<path d="M100 50L81.25 68.1865L81.25 31.8135L100 50Z" fill="currentColor" />
<line x1="5" y1="37" x2="73" y2="37"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="52" y1="8" x2="52" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="5" y1="62" x2="73" y2="62"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="27" y1="8" x2="27" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />`;
var icon_decrease_heading = `<path d="M2.50422e-07 50L18.75 31.8135L18.75 68.1865L2.50422e-07 50Z" fill="currentColor" />
<line x1="27" y1="37" x2="95" y2="37"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="74" y1="8" x2="74" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="27" y1="62" x2="95" y2="62"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
<line x1="49" y1="8" x2="49" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round" />
`;
var icon_heading_0 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M48.9929 65.7955C46.3509 65.786 44.0687 65.1752 42.1463 63.9631C40.224 62.7509 38.742 61.0038 37.7003 58.7216C36.6586 56.4394 36.1425 53.7027 36.152 50.5114C36.1615 47.3106 36.6823 44.5928 37.7145 42.358C38.7562 40.1231 40.2334 38.4233 42.1463 37.2585C44.0687 36.0937 46.3509 35.5114 48.9929 35.5114C51.6349 35.5114 53.9171 36.0985 55.8395 37.2727C57.7618 38.4375 59.2438 40.1373 60.2855 42.3722C61.3272 44.607 61.8433 47.3201 61.8338 50.5114C61.8338 53.7216 61.313 56.4678 60.2713 58.75C59.2296 61.0322 57.7476 62.7794 55.8253 63.9915C53.9124 65.1941 51.6349 65.7955 48.9929 65.7955ZM48.9929 59.375C50.3565 59.375 51.474 58.6648 52.3452 57.2443C53.2259 55.8144 53.6615 53.5701 53.652 50.5114C53.652 48.5133 53.4531 46.8797 53.0554 45.6108C52.6577 44.3419 52.1084 43.4044 51.4077 42.7983C50.7069 42.1828 49.902 41.875 48.9929 41.875C47.6293 41.875 46.5166 42.5663 45.6548 43.9489C44.7931 45.3314 44.3527 47.5189 44.3338 50.5114C44.3243 52.5473 44.5185 54.2235 44.9162 55.5398C45.3139 56.8466 45.8632 57.8125 46.5639 58.4375C47.2741 59.0625 48.0838 59.375 48.9929 59.375Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_1 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M55.576 35.9091V65H47.6783V43.1818H47.5078L41.1442 46.9886V40.2841L48.3033 35.9091H55.576Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_2 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M38.0021 65V59.3182L48.8544 50.3409C49.5741 49.7443 50.1896 49.1856 50.701 48.6648C51.2218 48.1345 51.6196 47.59 51.8942 47.0312C52.1783 46.4725 52.3203 45.8523 52.3203 45.1705C52.3203 44.4223 52.1593 43.7831 51.8374 43.2528C51.5249 42.7225 51.0893 42.3153 50.5305 42.0312C49.9718 41.7377 49.3279 41.5909 48.5987 41.5909C47.8696 41.5909 47.2256 41.7377 46.6669 42.0312C46.1177 42.3248 45.6915 42.7557 45.3885 43.3239C45.0855 43.892 44.9339 44.5833 44.9339 45.3977H37.4339C37.4339 43.3523 37.8932 41.5909 38.8118 40.1136C39.7304 38.6364 41.0277 37.5 42.7038 36.7045C44.38 35.9091 46.3449 35.5114 48.5987 35.5114C50.9283 35.5114 52.9453 35.8854 54.6499 36.6335C56.3639 37.3722 57.6849 38.4138 58.6129 39.7585C59.5504 41.1032 60.0192 42.6799 60.0192 44.4886C60.0192 45.6061 59.7872 46.7187 59.3232 47.8267C58.8591 48.9252 58.0258 50.142 56.8232 51.4773C55.6205 52.8125 53.9112 54.4034 51.6953 56.25L48.968 58.5227V58.6932H60.3317V65H38.0021Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_3 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M49.2994 65.3977C47.0077 65.3977 44.9717 65.0047 43.1914 64.2188C41.4206 63.4233 40.0285 62.3295 39.0153 60.9375C38.002 59.5455 37.4906 57.9451 37.4812 56.1364H45.4357C45.4452 56.6951 45.6156 57.197 45.9471 57.642C46.288 58.0777 46.752 58.4186 47.3391 58.6648C47.9263 58.911 48.5986 59.0341 49.3562 59.0341C50.0853 59.0341 50.7293 58.9062 51.288 58.6506C51.8467 58.3854 52.2823 58.0208 52.5948 57.5568C52.9073 57.0928 53.0588 56.5625 53.0494 55.9659C53.0588 55.3788 52.8789 54.858 52.5096 54.4034C52.1497 53.9489 51.6431 53.5937 50.9897 53.3381C50.3363 53.0824 49.5835 52.9545 48.7312 52.9545H45.7766V47.5H48.7312C49.5172 47.5 50.2085 47.3722 50.805 47.1165C51.4111 46.8608 51.8799 46.5057 52.2113 46.0511C52.5522 45.5966 52.7179 45.0758 52.7085 44.4886C52.7179 43.9205 52.5806 43.4186 52.2965 42.983C52.0124 42.5473 51.6147 42.2064 51.1033 41.9602C50.6014 41.714 50.0191 41.5909 49.3562 41.5909C48.6365 41.5909 47.9925 41.7187 47.4244 41.9744C46.8656 42.2301 46.4253 42.5852 46.1033 43.0398C45.7814 43.4943 45.6156 44.0152 45.6062 44.6023H38.0494C38.0588 42.822 38.5465 41.25 39.5124 39.8864C40.4878 38.5227 41.823 37.4527 43.5181 36.6761C45.2132 35.8996 47.1592 35.5114 49.3562 35.5114C51.5058 35.5114 53.4045 35.8759 55.0522 36.6051C56.7094 37.3343 58.002 38.3381 58.93 39.6165C59.8675 40.8854 60.3316 42.339 60.3221 43.9773C60.341 45.6061 59.7823 46.9413 58.646 47.983C57.5191 49.0246 56.0891 49.6402 54.3562 49.8295V50.0568C56.7047 50.3125 58.4708 51.0322 59.6545 52.2159C60.8382 53.3902 61.4206 54.8674 61.4016 56.6477C61.4111 58.3523 60.8997 59.8627 59.8675 61.179C58.8448 62.4953 57.4196 63.5275 55.592 64.2756C53.7738 65.0237 51.6763 65.3977 49.2994 65.3977Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_4 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M37.1048 60.4545V54.3182L48.8093 35.9091H54.3775V44.0909H51.1957L44.8888 54.0909V54.3182H62.1616V60.4545H37.1048ZM51.2525 65V58.5795L51.4229 55.9091V35.9091H58.8093V65H51.2525Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_5 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M49.7006 65.3977C47.4658 65.3977 45.4819 65.0047 43.7489 64.2188C42.0254 63.4233 40.6665 62.3295 39.6722 60.9375C38.6874 59.5455 38.1855 57.9451 38.1665 56.1364H45.837C45.8654 57.1402 46.2537 57.9403 47.0018 58.5369C47.7594 59.1335 48.659 59.4318 49.7006 59.4318C50.5056 59.4318 51.2158 59.2614 51.8313 58.9205C52.4469 58.5701 52.9298 58.0777 53.2802 57.4432C53.6306 56.8087 53.801 56.0701 53.7915 55.2273C53.801 54.375 53.6306 53.6364 53.2802 53.0114C52.9298 52.3769 52.4469 51.8892 51.8313 51.5483C51.2158 51.1979 50.5056 51.0227 49.7006 51.0227C48.8673 51.0227 48.0955 51.2263 47.3853 51.6335C46.6845 52.0312 46.1684 52.5852 45.837 53.2955L38.9052 51.9318L40.0415 35.9091H59.587V42.2159H46.5188L45.9506 48.6364H46.1211C46.5756 47.7557 47.3616 47.0265 48.479 46.4489C49.5965 45.8617 50.8938 45.5682 52.3711 45.5682C54.104 45.5682 55.6476 45.9706 57.0018 46.7756C58.3654 47.5805 59.4402 48.6932 60.2262 50.1136C61.0217 51.5246 61.4147 53.1534 61.4052 55C61.4147 57.0265 60.9317 58.8258 59.9563 60.3977C58.9904 61.9602 57.6315 63.1866 55.8796 64.0767C54.1277 64.9574 52.0681 65.3977 49.7006 65.3977Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;
var icon_heading_6 = `
<path d="M12 22H88"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<line x1="71" y1="8" x2="71" y2="92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M49.3995 65.3977C47.7044 65.3977 46.0946 65.1326 44.57 64.6023C43.0548 64.0625 41.7101 63.215 40.5359 62.0597C39.3616 60.9044 38.4383 59.3987 37.766 57.5426C37.1031 55.6866 36.7764 53.4375 36.7859 50.7955C36.7953 48.4375 37.0984 46.3163 37.695 44.4318C38.301 42.5473 39.158 40.9422 40.266 39.6165C41.3834 38.2907 42.7186 37.2775 44.2717 36.5767C45.8247 35.8665 47.5529 35.5114 49.4563 35.5114C51.5965 35.5114 53.4809 35.9233 55.1097 36.7472C56.7385 37.571 58.0359 38.6742 59.0018 40.0568C59.9772 41.4299 60.5453 42.9451 60.7063 44.6023H52.9222C52.7423 43.7784 52.3256 43.1771 51.6722 42.7983C51.0283 42.41 50.2897 42.2159 49.4563 42.2159C47.7991 42.2159 46.5823 42.9356 45.8058 44.375C45.0387 45.8144 44.6457 47.7083 44.6268 50.0568H44.7972C45.1665 49.1667 45.7253 48.4044 46.4734 47.7699C47.2215 47.1354 48.0927 46.6477 49.087 46.3068C50.0813 45.9659 51.1325 45.7955 52.2404 45.7955C54.0018 45.7955 55.5406 46.1932 56.8569 46.9886C58.1826 47.7841 59.2148 48.8731 59.9535 50.2557C60.6921 51.6383 61.0567 53.2197 61.0472 55C61.0567 57.0833 60.5643 58.9062 59.57 60.4688C58.5851 62.0312 57.2167 63.2434 55.4648 64.1051C53.713 64.9669 51.6912 65.3977 49.3995 65.3977ZM49.3427 59.4318C50.1287 59.4318 50.8247 59.2519 51.4308 58.892C52.0463 58.5322 52.5245 58.0398 52.8654 57.4148C53.2158 56.7898 53.3862 56.0795 53.3768 55.2841C53.3862 54.4792 53.2158 53.7689 52.8654 53.1534C52.5245 52.5284 52.0463 52.036 51.4308 51.6761C50.8247 51.3163 50.1287 51.1364 49.3427 51.1364C48.765 51.1364 48.23 51.2405 47.7376 51.4489C47.2546 51.6477 46.8332 51.9366 46.4734 52.3153C46.1135 52.6847 45.8294 53.125 45.6211 53.6364C45.4222 54.1383 45.3181 54.6875 45.3086 55.2841C45.3181 56.0795 45.498 56.7898 45.8484 57.4148C46.1987 58.0398 46.677 58.5322 47.283 58.892C47.8891 59.2519 48.5756 59.4318 49.3427 59.4318Z"  fill="currentColor"/>
<line x1="11" y1="78" x2="89" y2="78"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>
<path d="M28 8L28 92"  stroke="currentColor" stroke-width="10" stroke-linecap="round"/>`;

// src/services/interfaceService.ts
var InterfaceService = class {
  constructor() {
    __publicField(this, "addIcons", () => {
      (0, import_obsidian2.addIcon)("headingShifter_decreaseIcon", icon_decrease_heading);
      (0, import_obsidian2.addIcon)("headingShifter_increaseIcon", icon_increase_heading);
      (0, import_obsidian2.addIcon)("headingShifter_heading0", icon_heading_0);
      (0, import_obsidian2.addIcon)("headingShifter_heading1", icon_heading_1);
      (0, import_obsidian2.addIcon)("headingShifter_heading2", icon_heading_2);
      (0, import_obsidian2.addIcon)("headingShifter_heading3", icon_heading_3);
      (0, import_obsidian2.addIcon)("headingShifter_heading4", icon_heading_4);
      (0, import_obsidian2.addIcon)("headingShifter_heading5", icon_heading_5);
      (0, import_obsidian2.addIcon)("headingShifter_heading6", icon_heading_6);
    });
  }
  exec() {
    this.addIcons();
  }
};

// src/services/obsidianService.ts
var import_obsidian3 = require("obsidian");
var ObsidianService = class {
  constructor() {
  }
  getEditorFromState(state) {
    return state.field(import_obsidian3.editorInfoField).editor;
  }
  createKeyMapRunCallback(config) {
    const check = config.check || (() => true);
    const { run } = config;
    return (view) => {
      const editor = this.getEditorFromState(view.state);
      if (!editor) {
        return false;
      }
      if (!check(editor)) {
        return false;
      }
      const shouldStopPropagation = run(editor);
      return shouldStopPropagation;
    };
  }
};

// src/services/registerService.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/constant/editor.ts
var TABSIZE = 4;

// src/constant/regExp.ts
var RegExpExample = {
  beginning: {
    ol: String.raw`\d+\. `,
    ul: String.raw`(?:\-|\*) `
  },
  surrounding: {
    // Only one match
    italic: String.raw`(?:(?<!\*)\*(?!\*)|(?<!_)_(?!_))`,
    // Same
    // bold: String.raw`(?:\*\*|__)`,
    bold: String.raw`(?:(?<!\*)\*\*(?!\*)|(?<!_)__(?!_))`
  }
};

// node_modules/ts-pattern/dist/index.js
var t = Symbol.for("@ts-pattern/matcher");
var e = Symbol.for("@ts-pattern/isVariadic");
var n = "@ts-pattern/anonymous-select-key";
var r = (t2) => Boolean(t2 && "object" == typeof t2);
var i = (e2) => e2 && !!e2[t];
var o = (n2, s2, c2) => {
  if (i(n2)) {
    const e2 = n2[t](), { matched: r2, selections: i2 } = e2.match(s2);
    return r2 && i2 && Object.keys(i2).forEach((t2) => c2(t2, i2[t2])), r2;
  }
  if (r(n2)) {
    if (!r(s2)) return false;
    if (Array.isArray(n2)) {
      if (!Array.isArray(s2)) return false;
      let t2 = [], r2 = [], u2 = [];
      for (const o2 of n2.keys()) {
        const s3 = n2[o2];
        i(s3) && s3[e] ? u2.push(s3) : u2.length ? r2.push(s3) : t2.push(s3);
      }
      if (u2.length) {
        if (u2.length > 1) throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
        if (s2.length < t2.length + r2.length) return false;
        const e2 = s2.slice(0, t2.length), n3 = 0 === r2.length ? [] : s2.slice(-r2.length), i2 = s2.slice(t2.length, 0 === r2.length ? Infinity : -r2.length);
        return t2.every((t3, n4) => o(t3, e2[n4], c2)) && r2.every((t3, e3) => o(t3, n3[e3], c2)) && (0 === u2.length || o(u2[0], i2, c2));
      }
      return n2.length === s2.length && n2.every((t3, e2) => o(t3, s2[e2], c2));
    }
    return Reflect.ownKeys(n2).every((e2) => {
      const r2 = n2[e2];
      return (e2 in s2 || i(u2 = r2) && "optional" === u2[t]().matcherType) && o(r2, s2[e2], c2);
      var u2;
    });
  }
  return Object.is(s2, n2);
};
var s = (e2) => {
  var n2, o2, u2;
  return r(e2) ? i(e2) ? null != (n2 = null == (o2 = (u2 = e2[t]()).getSelectionKeys) ? void 0 : o2.call(u2)) ? n2 : [] : Array.isArray(e2) ? c(e2, s) : c(Object.values(e2), s) : [];
};
var c = (t2, e2) => t2.reduce((t3, n2) => t3.concat(e2(n2)), []);
function u(...t2) {
  if (1 === t2.length) {
    const [e2] = t2;
    return (t3) => o(e2, t3, () => {
    });
  }
  if (2 === t2.length) {
    const [e2, n2] = t2;
    return o(e2, n2, () => {
    });
  }
  throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${t2.length}.`);
}
function a(t2) {
  return Object.assign(t2, { optional: () => h(t2), and: (e2) => d(t2, e2), or: (e2) => y(t2, e2), select: (e2) => void 0 === e2 ? v(t2) : v(e2, t2) });
}
function l(t2) {
  return Object.assign(((t3) => Object.assign(t3, { [Symbol.iterator]() {
    let n2 = 0;
    const r2 = [{ value: Object.assign(t3, { [e]: true }), done: false }, { done: true, value: void 0 }];
    return { next: () => {
      var t4;
      return null != (t4 = r2[n2++]) ? t4 : r2.at(-1);
    } };
  } }))(t2), { optional: () => l(h(t2)), select: (e2) => l(void 0 === e2 ? v(t2) : v(e2, t2)) });
}
function h(e2) {
  return a({ [t]: () => ({ match: (t2) => {
    let n2 = {};
    const r2 = (t3, e3) => {
      n2[t3] = e3;
    };
    return void 0 === t2 ? (s(e2).forEach((t3) => r2(t3, void 0)), { matched: true, selections: n2 }) : { matched: o(e2, t2, r2), selections: n2 };
  }, getSelectionKeys: () => s(e2), matcherType: "optional" }) });
}
var f = (t2, e2) => {
  for (const n2 of t2) if (!e2(n2)) return false;
  return true;
};
var g = (t2, e2) => {
  for (const [n2, r2] of t2.entries()) if (!e2(r2, n2)) return false;
  return true;
};
var m = (t2, e2) => {
  const n2 = Reflect.ownKeys(t2);
  for (const r2 of n2) if (!e2(r2, t2[r2])) return false;
  return true;
};
function d(...e2) {
  return a({ [t]: () => ({ match: (t2) => {
    let n2 = {};
    const r2 = (t3, e3) => {
      n2[t3] = e3;
    };
    return { matched: e2.every((e3) => o(e3, t2, r2)), selections: n2 };
  }, getSelectionKeys: () => c(e2, s), matcherType: "and" }) });
}
function y(...e2) {
  return a({ [t]: () => ({ match: (t2) => {
    let n2 = {};
    const r2 = (t3, e3) => {
      n2[t3] = e3;
    };
    return c(e2, s).forEach((t3) => r2(t3, void 0)), { matched: e2.some((e3) => o(e3, t2, r2)), selections: n2 };
  }, getSelectionKeys: () => c(e2, s), matcherType: "or" }) });
}
function p(e2) {
  return { [t]: () => ({ match: (t2) => ({ matched: Boolean(e2(t2)) }) }) };
}
function v(...e2) {
  const r2 = "string" == typeof e2[0] ? e2[0] : void 0, i2 = 2 === e2.length ? e2[1] : "string" == typeof e2[0] ? void 0 : e2[0];
  return a({ [t]: () => ({ match: (t2) => {
    let e3 = { [null != r2 ? r2 : n]: t2 };
    return { matched: void 0 === i2 || o(i2, t2, (t3, n2) => {
      e3[t3] = n2;
    }), selections: e3 };
  }, getSelectionKeys: () => [null != r2 ? r2 : n].concat(void 0 === i2 ? [] : s(i2)) }) });
}
function b(t2) {
  return true;
}
function w(t2) {
  return "number" == typeof t2;
}
function S(t2) {
  return "string" == typeof t2;
}
function j(t2) {
  return "bigint" == typeof t2;
}
var K = a(p(b));
var O = a(p(b));
var E = K;
var x = (t2) => Object.assign(a(t2), { startsWith: (e2) => {
  return x(d(t2, (n2 = e2, p((t3) => S(t3) && t3.startsWith(n2)))));
  var n2;
}, endsWith: (e2) => {
  return x(d(t2, (n2 = e2, p((t3) => S(t3) && t3.endsWith(n2)))));
  var n2;
}, minLength: (e2) => x(d(t2, ((t3) => p((e3) => S(e3) && e3.length >= t3))(e2))), length: (e2) => x(d(t2, ((t3) => p((e3) => S(e3) && e3.length === t3))(e2))), maxLength: (e2) => x(d(t2, ((t3) => p((e3) => S(e3) && e3.length <= t3))(e2))), includes: (e2) => {
  return x(d(t2, (n2 = e2, p((t3) => S(t3) && t3.includes(n2)))));
  var n2;
}, regex: (e2) => {
  return x(d(t2, (n2 = e2, p((t3) => S(t3) && Boolean(t3.match(n2))))));
  var n2;
} });
var A = x(p(S));
var N = (t2) => Object.assign(a(t2), { between: (e2, n2) => N(d(t2, ((t3, e3) => p((n3) => w(n3) && t3 <= n3 && e3 >= n3))(e2, n2))), lt: (e2) => N(d(t2, ((t3) => p((e3) => w(e3) && e3 < t3))(e2))), gt: (e2) => N(d(t2, ((t3) => p((e3) => w(e3) && e3 > t3))(e2))), lte: (e2) => N(d(t2, ((t3) => p((e3) => w(e3) && e3 <= t3))(e2))), gte: (e2) => N(d(t2, ((t3) => p((e3) => w(e3) && e3 >= t3))(e2))), int: () => N(d(t2, p((t3) => w(t3) && Number.isInteger(t3)))), finite: () => N(d(t2, p((t3) => w(t3) && Number.isFinite(t3)))), positive: () => N(d(t2, p((t3) => w(t3) && t3 > 0))), negative: () => N(d(t2, p((t3) => w(t3) && t3 < 0))) });
var P = N(p(w));
var k = (t2) => Object.assign(a(t2), { between: (e2, n2) => k(d(t2, ((t3, e3) => p((n3) => j(n3) && t3 <= n3 && e3 >= n3))(e2, n2))), lt: (e2) => k(d(t2, ((t3) => p((e3) => j(e3) && e3 < t3))(e2))), gt: (e2) => k(d(t2, ((t3) => p((e3) => j(e3) && e3 > t3))(e2))), lte: (e2) => k(d(t2, ((t3) => p((e3) => j(e3) && e3 <= t3))(e2))), gte: (e2) => k(d(t2, ((t3) => p((e3) => j(e3) && e3 >= t3))(e2))), positive: () => k(d(t2, p((t3) => j(t3) && t3 > 0))), negative: () => k(d(t2, p((t3) => j(t3) && t3 < 0))) });
var T = k(p(j));
var B = a(p(function(t2) {
  return "boolean" == typeof t2;
}));
var _ = a(p(function(t2) {
  return "symbol" == typeof t2;
}));
var W = a(p(function(t2) {
  return null == t2;
}));
var $ = a(p(function(t2) {
  return null != t2;
}));
var z = { __proto__: null, matcher: t, optional: h, array: function(...e2) {
  return l({ [t]: () => ({ match: (t2) => {
    if (!Array.isArray(t2)) return { matched: false };
    if (0 === e2.length) return { matched: true };
    const n2 = e2[0];
    let r2 = {};
    if (0 === t2.length) return s(n2).forEach((t3) => {
      r2[t3] = [];
    }), { matched: true, selections: r2 };
    const i2 = (t3, e3) => {
      r2[t3] = (r2[t3] || []).concat([e3]);
    };
    return { matched: t2.every((t3) => o(n2, t3, i2)), selections: r2 };
  }, getSelectionKeys: () => 0 === e2.length ? [] : s(e2[0]) }) });
}, set: function(...e2) {
  return a({ [t]: () => ({ match: (t2) => {
    if (!(t2 instanceof Set)) return { matched: false };
    let n2 = {};
    if (0 === t2.size) return { matched: true, selections: n2 };
    if (0 === e2.length) return { matched: true };
    const r2 = (t3, e3) => {
      n2[t3] = (n2[t3] || []).concat([e3]);
    }, i2 = e2[0];
    return { matched: f(t2, (t3) => o(i2, t3, r2)), selections: n2 };
  }, getSelectionKeys: () => 0 === e2.length ? [] : s(e2[0]) }) });
}, map: function(...e2) {
  return a({ [t]: () => ({ match: (t2) => {
    if (!(t2 instanceof Map)) return { matched: false };
    let n2 = {};
    if (0 === t2.size) return { matched: true, selections: n2 };
    const r2 = (t3, e3) => {
      n2[t3] = (n2[t3] || []).concat([e3]);
    };
    if (0 === e2.length) return { matched: true };
    var i2;
    if (1 === e2.length) throw new Error(`\`P.map\` wasn't given enough arguments. Expected (key, value), received ${null == (i2 = e2[0]) ? void 0 : i2.toString()}`);
    const [s2, c2] = e2;
    return { matched: g(t2, (t3, e3) => {
      const n3 = o(s2, e3, r2), i3 = o(c2, t3, r2);
      return n3 && i3;
    }), selections: n2 };
  }, getSelectionKeys: () => 0 === e2.length ? [] : [...s(e2[0]), ...s(e2[1])] }) });
}, record: function(...e2) {
  return a({ [t]: () => ({ match: (t2) => {
    if (null === t2 || "object" != typeof t2 || Array.isArray(t2)) return { matched: false };
    var n2;
    if (0 === e2.length) throw new Error(`\`P.record\` wasn't given enough arguments. Expected (value) or (key, value), received ${null == (n2 = e2[0]) ? void 0 : n2.toString()}`);
    let r2 = {};
    const i2 = (t3, e3) => {
      r2[t3] = (r2[t3] || []).concat([e3]);
    }, [s2, c2] = 1 === e2.length ? [A, e2[0]] : e2;
    return { matched: m(t2, (t3, e3) => {
      const n3 = "string" != typeof t3 || Number.isNaN(Number(t3)) ? null : Number(t3), r3 = null !== n3 && o(s2, n3, i2), u2 = o(s2, t3, i2), a2 = o(c2, e3, i2);
      return (u2 || r3) && a2;
    }), selections: r2 };
  }, getSelectionKeys: () => 0 === e2.length ? [] : [...s(e2[0]), ...s(e2[1])] }) });
}, intersection: d, union: y, not: function(e2) {
  return a({ [t]: () => ({ match: (t2) => ({ matched: !o(e2, t2, () => {
  }) }), getSelectionKeys: () => [], matcherType: "not" }) });
}, when: p, select: v, any: K, unknown: O, _: E, string: A, number: P, bigint: T, boolean: B, symbol: _, nullish: W, nonNullable: $, instanceOf: function(t2) {
  return a(p(/* @__PURE__ */ (function(t3) {
    return (e2) => e2 instanceof t3;
  })(t2)));
}, shape: function(t2) {
  return a(p(u(t2)));
} };
var I = class extends Error {
  constructor(t2) {
    let e2;
    try {
      e2 = JSON.stringify(t2);
    } catch (n2) {
      e2 = t2;
    }
    super(`Pattern matching error: no pattern matches value ${e2}`), this.input = void 0, this.input = t2;
  }
};
var L = { matched: false, value: void 0 };
function M(t2) {
  return new R(t2, L);
}
var R = class _R {
  constructor(t2, e2) {
    this.input = void 0, this.state = void 0, this.input = t2, this.state = e2;
  }
  with(...t2) {
    if (this.state.matched) return this;
    const e2 = t2[t2.length - 1], r2 = [t2[0]];
    let i2;
    3 === t2.length && "function" == typeof t2[1] ? i2 = t2[1] : t2.length > 2 && r2.push(...t2.slice(1, t2.length - 1));
    let s2 = false, c2 = {};
    const u2 = (t3, e3) => {
      s2 = true, c2[t3] = e3;
    }, a2 = !r2.some((t3) => o(t3, this.input, u2)) || i2 && !Boolean(i2(this.input)) ? L : { matched: true, value: e2(s2 ? n in c2 ? c2[n] : c2 : this.input, this.input) };
    return new _R(this.input, a2);
  }
  when(t2, e2) {
    if (this.state.matched) return this;
    const n2 = Boolean(t2(this.input));
    return new _R(this.input, n2 ? { matched: true, value: e2(this.input, this.input) } : L);
  }
  otherwise(t2) {
    return this.state.matched ? this.state.value : t2(this.input);
  }
  exhaustive(t2 = F) {
    return this.state.matched ? this.state.value : t2(this.input);
  }
  run() {
    return this.exhaustive();
  }
  returnType() {
    return this;
  }
  narrow() {
    return this;
  }
};
function F(t2) {
  throw new I(t2);
}

// src/utils/range.ts
var setMin = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur < prev) {
    return cur;
  }
  return prev;
};
var setMax = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur > prev) {
    return cur;
  }
  return prev;
};
var createRange = (start, num) => Array.from(Array(num), (v2, k2) => k2 + start);

// src/utils/markdown.ts
var checkHeading = (content) => {
  const match = content.match(/^(#+) /);
  if (!match || !match[1]) return 0;
  return match[1].length;
};
var checkFence = (content) => {
  const backticks = content.match(/^(`{3,})/);
  if (backticks == null ? void 0 : backticks[1]) return { fenceType: "`", fenceNum: backticks[1].length };
  const tildes = content.match(/^(~{3,})/);
  if (tildes == null ? void 0 : tildes[1]) return { fenceType: "~", fenceNum: tildes[1].length };
  return null;
};
var getFenceStatus = (prev, current2) => {
  if (!current2) return prev;
  if (!prev) return current2;
  if (current2.fenceType === prev.fenceType && current2.fenceNum >= prev.fenceNum) {
    return null;
  }
  return prev;
};
var getHeadingLines = (editor, from, to, options) => {
  const headingLines = [];
  let minHeading;
  let maxHeading;
  let fence = null;
  for (let line = Math.min(from, to); line <= Math.max(from, to); line++) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence) continue;
    const heading = checkHeading(editor.getLine(line));
    if ((options == null ? void 0 : options.includesNoHeadingsLine) || heading > 0) {
      headingLines.push(line);
      minHeading = setMin(minHeading, heading);
      maxHeading = setMax(maxHeading, heading);
    }
  }
  return { headingLines, minHeading, maxHeading };
};
var getPreviousHeading = (editor, from) => {
  let fence = null;
  const start = from > 0 ? from - 1 : 0;
  for (let line = start; line >= 0; line--) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence) continue;
    if (checkHeading(editor.getLine(line)) > 0) {
      return line;
    }
  }
  return void 0;
};
var replaceFunc = (str, regExp) => {
  try {
    const replaced = str.replace(regExp, "$1");
    if (replaced !== str) {
      return replaced;
    }
  } catch (error) {
    console.error(error);
  }
  return void 0;
};
var removeUsingRegexpStrings = (str, regExpStrings) => {
  var _a, _b;
  let removed = str;
  for (const regExpStr of (_a = regExpStrings.beginning) != null ? _a : []) {
    const regExp = new RegExp(`^\\s*${regExpStr}(.*)`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  for (const regExpStr of (_b = regExpStrings.surrounding) != null ? _b : []) {
    const regExp = new RegExp(`${regExpStr}(.*)${regExpStr}`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  return removed;
};
var countIndentLevel = (line, tabSize = TABSIZE) => {
  var _a;
  const leadingContent = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[0];
  if (!leadingContent) return 0;
  const tabCount = (leadingContent.match(/\t/g) || []).length;
  const spaceCount = (leadingContent.match(/ /g) || []).length;
  return tabCount + Math.floor(spaceCount / tabSize);
};
var getListChildrenLines = (editor, {
  parentLineNumber,
  tabSize
}) => {
  const lineNumbers = [];
  const startLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(startLine, tabSize);
  for (let lineN = parentLineNumber + 1; lineN < editor.lineCount(); lineN++) {
    const line = editor.getLine(lineN);
    const indentLevel = countIndentLevel(line, tabSize);
    const isBulleted = /^\s*[-*]\s+/.test(line);
    const isNumbered = /^\s*\d+\.\s+/.test(line);
    if (!isBulleted && !isNumbered) break;
    if (indentLevel <= prevParentIndentLevel) break;
    lineNumbers.push(lineN);
  }
  return lineNumbers;
};

// src/utils/editorChange.ts
var composeLineChanges = (editor, lineNumbers, changeCallback, settings) => {
  const editorChange = [];
  for (const line of lineNumbers) {
    const shifted = changeCallback(editor.getLine(line), settings);
    editorChange.push({
      text: shifted,
      from: { line, ch: 0 },
      to: {
        line,
        ch: editor.getLine(line).length
      }
    });
  }
  return editorChange;
};
var createListIndentChanges = (editor, {
  parentLineNumber,
  parentIndentLevel,
  tabSize = TABSIZE,
  changeHeadingLevel
}) => {
  const parentLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(parentLine, tabSize);
  const childrenNumbers = getListChildrenLines(editor, {
    parentLineNumber,
    tabSize
  });
  const indentDelta = parentIndentLevel - prevParentIndentLevel;
  const changes = [];
  childrenNumbers.forEach((lineNumber) => {
    var _a, _b, _c, _d;
    const line = editor.getLine(lineNumber);
    const newIndentLevel = Math.max(
      countIndentLevel(line, tabSize) + indentDelta,
      0
    );
    const matchResult = line.match(
      new RegExp("^(?<whitespace>\\s*)(?<bullet>[-*]\\s*|(?<numbered>\\d+\\.\\s*))(?<heading>#+\\s*)?(?<content>.*)$")
    );
    const tabsMarkers = "	".repeat(newIndentLevel);
    const bulletMarkers = ((_a = matchResult == null ? void 0 : matchResult.groups) == null ? void 0 : _a.bullet) || "";
    const numberedMarkers = ((_b = matchResult == null ? void 0 : matchResult.groups) == null ? void 0 : _b.numbered) || "";
    const listMarker = bulletMarkers || numberedMarkers;
    const headingMarkers = M({
      heading: (_c = matchResult == null ? void 0 : matchResult.groups) == null ? void 0 : _c.heading,
      changeHeadingLevel
    }).with({ heading: void 0, changeHeadingLevel: z._ }, () => "").with(
      { heading: z._, changeHeadingLevel: true },
      () => `${"#".repeat(Math.min(newIndentLevel + 1, 6))} `
    ).with(
      { heading: z._, changeHeadingLevel: z.not(true) },
      ({ heading }) => heading
    ).exhaustive();
    const content = ((_d = matchResult == null ? void 0 : matchResult.groups) == null ? void 0 : _d.content) || "";
    const newLine = `${tabsMarkers}${listMarker}${headingMarkers}${content}`;
    changes.push({
      text: newLine,
      from: { line: lineNumber, ch: 0 },
      to: { line: lineNumber, ch: line.length }
    });
  });
  return changes;
};

// src/features/applyHeading/module.ts
var applyHeading = (chunk, headingSize, settings) => {
  var _a;
  const extractRegExp = (settingObj, regExpObj) => {
    return Object.entries(settingObj != null ? settingObj : {}).flatMap(([k2, v2]) => {
      var _a2;
      if (Array.isArray(v2)) {
        return v2;
      }
      if (k2 in regExpObj && v2 === true) {
        return (_a2 = regExpObj[k2]) != null ? _a2 : [];
      }
      return [];
    });
  };
  const bulletRegExp = /\s*(- \[.+\]|-|\*|[0-9]+)\s+/;
  const headingRegExp = /#+\s+/;
  const isBullet = ((_a = settings == null ? void 0 : settings.list) == null ? void 0 : _a.childrenBehavior) === "sync with headings" && bulletRegExp.test(chunk);
  let removed = chunk;
  if (!checkHeading(chunk)) {
    removed = (settings == null ? void 0 : settings.styleToRemove) ? removeUsingRegexpStrings(chunk, {
      beginning: extractRegExp(
        __spreadProps(__spreadValues({}, settings.styleToRemove.beginning), {
          ul: !isBullet && settings.styleToRemove.beginning.ul
        }),
        RegExpExample.beginning
      ),
      surrounding: extractRegExp(
        settings.styleToRemove.surrounding,
        RegExpExample.surrounding
      )
    }) : chunk;
  }
  const leadingMarkersRegExp = isBullet ? new RegExp(
    `^(?:${bulletRegExp.source}${headingRegExp.source}|${bulletRegExp.source})`
  ) : new RegExp(`^${headingRegExp.source}`);
  let capturedBullet = "-";
  const principleText = removed.replace(leadingMarkersRegExp, (match, p1) => {
    if (isBullet && p1) {
      capturedBullet = p1;
    }
    return "";
  });
  const bulletMarkers = `${"	".repeat(Math.max(headingSize - 1, 0))}${capturedBullet} `;
  const headingMarkers = "#".repeat(Math.max(headingSize, 0)) + (headingSize > 0 ? " " : "");
  const leadingMarkers = isBullet ? `${bulletMarkers}${headingMarkers}` : headingMarkers;
  return leadingMarkers + principleText;
};
var createListIndentChangesByListBehavior = (editor, {
  listBehavior,
  tabSize = TABSIZE,
  parentIndentLevel,
  parentLineNumber
}) => {
  if (listBehavior === "noting") {
    return [];
  }
  const parentIndentLevelByBehavior = M(listBehavior).with("sync with headings", () => Math.max(0, parentIndentLevel)).with(
    "outdent to zero",
    () => -countIndentLevel(editor.getLine(parentLineNumber + 1), tabSize) + countIndentLevel(editor.getLine(parentLineNumber), tabSize)
  ).exhaustive();
  const indentChanges = createListIndentChanges(editor, {
    parentLineNumber,
    parentIndentLevel: parentIndentLevelByBehavior,
    tabSize,
    changeHeadingLevel: listBehavior === "sync with headings"
  });
  return indentChanges;
};

// src/features/applyHeading/operation.ts
var ApplyHeading = class {
  constructor(settings, headingSize) {
    __publicField(this, "settings");
    __publicField(this, "headingSize");
    /** Return obsidian command object : apply heading
     * @params setting - plugin settings(Not in use now)
     * @params headingSize - The Heading Size to be applied
     */
    __publicField(this, "editorCallback", (editor) => {
      var _a;
      const lines = createRange(
        editor.getCursor("from").line,
        editor.getCursor("to").line - editor.getCursor("from").line + 1
      );
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const lastHeaderLineNumber = (_a = lines[lines.length - 1]) != null ? _a : 0;
      const headingsChanges = composeLineChanges(
        editor,
        lines,
        (chunk) => applyHeading(chunk, this.headingSize, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: this.headingSize - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: lastHeaderLineNumber
      });
      editor.transaction({
        changes: [...headingsChanges, ...indentChanges]
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return true;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: `apply-heading${this.headingSize}`,
        name: `Apply Heading ${this.headingSize}`,
        icon: `headingShifter_heading${this.headingSize}`,
        editorCallback: this.editorCallback
      };
    });
    __publicField(this, "check", () => {
      return this.settings.overrideTab;
    });
    this.settings = settings;
    this.headingSize = headingSize;
  }
};

// src/features/insertHeading/operation.ts
var import_obsidian4 = require("obsidian");
var InsertHeadingAtCurrentLevel = class {
  constructor(settings) {
    __publicField(this, "settings");
    __publicField(this, "editorCallback", (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine !== void 0 ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: `insert-heading-current`,
        name: `Insert Heading at current level`,
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    });
    this.settings = settings;
  }
};
var InsertHeadingAtDeeperLevel = class {
  constructor(settings) {
    __publicField(this, "settings");
    __publicField(this, "editorCallback", (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      if (headingLevel + 1 > 6) {
        new import_obsidian4.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const targetHeadingLevel = headingLevel + 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: `insert-heading-deeper`,
        name: `Insert Heading at one level deeper`,
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    });
    this.settings = settings;
  }
};
var InsertHeadingAtHigherLevel = class {
  constructor(settings) {
    __publicField(this, "settings");
    __publicField(this, "editorCallback", (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel - 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: `insert-heading-higher`,
        name: `Insert Heading at one level higher`,
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    });
    this.settings = settings;
  }
};

// src/features/shiftHeading/operation.ts
var import_obsidian5 = require("obsidian");

// src/features/shiftHeading/module.ts
var shiftHeading = (chunk, dir, settings) => {
  const heading = checkHeading(chunk);
  return applyHeading(chunk, heading + dir, settings);
};
var increaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, 1, settings);
};
var decreaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, -1, settings);
};

// src/features/shiftHeading/operation.ts
var IncreaseHeading = class {
  constructor(settings, includesNoHeadingsLine) {
    __publicField(this, "settings");
    __publicField(this, "includesNoHeadingsLine");
    __publicField(this, "editorCallback", (editor) => {
      const { headingLines, maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line,
        {
          includesNoHeadingsLine: this.includesNoHeadingsLine
        }
      );
      if (maxHeading !== void 0 && maxHeading >= 6) {
        new import_obsidian5.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        increaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: `increase-heading${this.includesNoHeadingsLine ? "-forced" : ""}`,
        name: `Increase Headings${this.includesNoHeadingsLine ? "(forced)" : ""}`,
        icon: "headingShifter_increaseIcon",
        editorCallback: this.editorCallback
      };
    });
    __publicField(this, "check", (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0) return false;
      return this.settings.overrideTab;
    });
    this.settings = settings;
    this.includesNoHeadingsLine = includesNoHeadingsLine;
  }
};
var DecreaseHeading = class {
  constructor(settings) {
    __publicField(this, "settings");
    __publicField(this, "editorCallback", (editor) => {
      const { headingLines, minHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (minHeading !== void 0 && minHeading <= Number(this.settings.limitHeadingFrom)) {
        new import_obsidian5.Notice(
          `Cannot Decrease (contains less than Heading${Number(
            this.settings.limitHeadingFrom
          )})`
        );
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        decreaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    });
    __publicField(this, "createCommand", () => {
      return {
        id: "decrease-heading",
        name: "Decrease Headings",
        icon: "headingShifter_decreaseIcon",
        editorCallback: this.editorCallback
      };
    });
    __publicField(this, "check", (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0) return false;
      return this.settings.overrideTab;
    });
    this.settings = settings;
  }
};

// src/services/registerService.ts
var RegisterService = class {
  constructor(plugin) {
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  exec() {
    this.addCommands();
  }
  addCommands() {
    const increaseHeading2 = new IncreaseHeading(this.plugin.settings, false);
    const increaseHeadingForced = new IncreaseHeading(
      this.plugin.settings,
      true
    );
    const decreaseHeading2 = new DecreaseHeading(this.plugin.settings);
    const insertHeadingAtCurrentLabel = new InsertHeadingAtCurrentLevel(
      this.plugin.settings
    );
    const insertHeadingAtDeeperLevel = new InsertHeadingAtDeeperLevel(
      this.plugin.settings
    );
    const insertHeadingAtHigherLevel = new InsertHeadingAtHigherLevel(
      this.plugin.settings
    );
    HEADINGS.forEach((heading) => {
      const applyHeading2 = new ApplyHeading(this.plugin.settings, heading);
      this.plugin.addCommand(applyHeading2.createCommand());
    });
    this.plugin.addCommand(increaseHeading2.createCommand());
    this.plugin.addCommand(increaseHeadingForced.createCommand());
    this.plugin.addCommand(decreaseHeading2.createCommand());
    this.plugin.addCommand(insertHeadingAtCurrentLabel.createCommand());
    this.plugin.addCommand(insertHeadingAtDeeperLevel.createCommand());
    this.plugin.addCommand(insertHeadingAtHigherLevel.createCommand());
    this.plugin.registerEditorExtension(
      import_state.Prec.highest(
        import_view.keymap.of([
          {
            key: "Tab",
            run: this.plugin.obsidianService.createKeyMapRunCallback({
              check: increaseHeading2.check,
              run: increaseHeading2.editorCallback
            })
          }
        ])
      )
    );
    this.plugin.registerEditorExtension(
      import_state.Prec.highest(
        import_view.keymap.of([
          {
            key: "s-Tab",
            run: this.plugin.obsidianService.createKeyMapRunCallback({
              check: decreaseHeading2.check,
              run: decreaseHeading2.editorCallback
            })
          }
        ])
      )
    );
  }
};

// src/main.ts
var HeadingShifter = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "obsidianService");
    __publicField(this, "interfaceService");
    __publicField(this, "registerService");
  }
  onload() {
    return __async(this, null, function* () {
      this.obsidianService = new ObsidianService();
      this.interfaceService = new InterfaceService();
      this.registerService = new RegisterService(this);
      yield this.loadSettings();
      this.registerService.exec();
      this.interfaceService.exec();
      this.addSettingTab(new HeadingShifterSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      const rawSettings = yield this.loadData();
      this.settings = migrateSettings({
        settings: rawSettings,
        latestVersion: this.manifest.version,
        migrationObject: MIGRATION_OBJECT
      });
      yield this.saveSettings();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};

/* nosourcemap */
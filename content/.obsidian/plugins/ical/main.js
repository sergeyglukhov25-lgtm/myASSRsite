/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({
  "node_modules/fast-content-type-parse/index.js"(exports, module2) {
    "use strict";
    var NullObject = function NullObject2() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = { type: "", parameters: new NullObject() };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse2(header) {
      if (typeof header !== "string") {
        throw new TypeError("argument header is required and must be a string");
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError("invalid media type");
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
      return result;
    }
    function safeParse2(header) {
      if (typeof header !== "string") {
        return defaultContentType;
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    module2.exports.default = { parse: parse2, safeParse: safeParse2 };
    module2.exports.parse = parse2;
    module2.exports.safeParse = safeParse2;
    module2.exports.defaultContentType = defaultContentType;
  }
});

// src/ObsidianIcalPlugin.ts
var ObsidianIcalPlugin_exports = {};
__export(ObsidianIcalPlugin_exports, {
  default: () => ObsidianIcalPlugin
});
module.exports = __toCommonJS(ObsidianIcalPlugin_exports);
var import_obsidian7 = require("obsidian");

// src/FileClient.ts
var import_obsidian3 = require("obsidian");

// src/Logger.ts
var import_obsidian = require("obsidian");
var Logger = class _Logger {
  constructor(isDebug) {
    this.isDebug = isDebug;
  }
  static getInstance(isDebug) {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger(isDebug != null ? isDebug : false);
    } else if (isDebug !== void 0) {
      _Logger.instance.isDebug = isDebug;
    }
    return _Logger.instance;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  log(message, object) {
    if (this.isDebug) {
      console.log("[" + (0, import_obsidian.moment)().format("YYYY-MM-DD-HH:mm:ss.SSS") + "][info][ical] " + message);
      if (object) {
        console.log(object);
      }
    }
  }
};
function logger(isDebug) {
  return Logger.getInstance(isDebug);
}
function log(message, object) {
  return Logger.getInstance().log(message, object);
}

// src/SettingsManager.ts
var import_obsidian2 = require("obsidian");

// src/Model/Settings.ts
var HOW_TO_PARSE_INTERNAL_LINKS = {
  DoNotModifyThem: "Do not modify them (default)",
  KeepTitle: "Keep the title",
  PreferTitle: "Prefer the title",
  RemoveThem: "Remove them"
};
var INCLUDE_EVENTS_OR_TODOS = {
  EventsOnly: "Events only",
  EventsAndTodos: "Events and TODO items",
  TodosOnly: "TODO items only"
};
var HOW_TO_PROCESS_MULTIPLE_DATES = {
  PreferDueDate: "Prefer due date (default)",
  PreferStartDate: "Prefer start date",
  CreateMultipleEvents: "Create an event per start/scheduled/due date"
};
var DEFAULT_SETTINGS = {
  githubPersonalAccessToken: "",
  githubGistId: "",
  githubUsername: "",
  filename: "obsidian.ics",
  isPeriodicSaveEnabled: true,
  periodicSaveInterval: 5,
  isSaveToGistEnabled: false,
  isSaveToFileEnabled: false,
  isSaveToWebEnabled: false,
  savePath: "",
  saveFileName: "",
  saveFileExtension: ".ical",
  howToParseInternalLinks: "DoNotModifyThem",
  // HOW_TO_PARSE_INTERNAL_LINKS.DoNotModifyThem,
  ignoreCompletedTasks: false,
  isDebug: false,
  includeEventsOrTodos: "EventsOnly",
  // INCLUDE_EVENTS_OR_TODOS.EventsOnly
  isOnlyTasksWithoutDatesAreTodos: true,
  ignoreOldTasks: false,
  oldTaskInDays: 365,
  howToProcessMultipleDates: "PreferDueDate",
  // HOW_TO_PROCESS_MULTIPLE_DATES.PreferDueDate,
  isDayPlannerPluginFormatEnabled: false,
  isIncludeTasksWithTags: false,
  includeTasksWithTags: "#calendar",
  isExcludeTasksWithTags: false,
  excludeTasksWithTags: "#ignore",
  rootPath: "/",
  isIncludeLinkInDescription: false,
  secretKey: ""
};

// src/SettingsManager.ts
var SettingsManager = class _SettingsManager {
  constructor(plugin) {
    if (plugin instanceof import_obsidian2.Plugin) {
      this.plugin = plugin;
    }
  }
  static async createInstance(plugin) {
    _SettingsManager.instance = new _SettingsManager(plugin);
    await this.instance.loadSettings();
    return _SettingsManager.instance;
  }
  static get settingsManager() {
    return _SettingsManager.instance;
  }
  async loadSettings() {
    log("Load settings");
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.plugin.loadData());
    await this.plugin.saveData(this.settings);
  }
  async saveSettings() {
    log("Save settings");
    await this.plugin.saveData(this.settings);
  }
  settingsWithoutSecrets() {
    return Object.assign({}, this.settings, {
      githubPersonalAccessToken: "<redacted>",
      githubGistId: "<redacted>",
      githubUsername: "<redacted>"
    });
  }
  get githubPersonalAccessToken() {
    return this.settings.githubPersonalAccessToken;
  }
  set githubPersonalAccessToken(githubPersonalAccessToken) {
    this.settings.githubPersonalAccessToken = githubPersonalAccessToken;
    this.saveSettings();
  }
  get githubGistId() {
    return this.settings.githubGistId;
  }
  set githubGistId(githubGistId) {
    this.settings.githubGistId = githubGistId;
    this.saveSettings();
  }
  get githubUsername() {
    return this.settings.githubUsername;
  }
  set githubUsername(githubUsername) {
    this.settings.githubUsername = githubUsername;
    this.saveSettings();
  }
  get filename() {
    return this.settings.filename;
  }
  set filename(filename) {
    this.settings.filename = filename;
    this.saveSettings();
  }
  get isPeriodicSaveEnabled() {
    return this.settings.isPeriodicSaveEnabled;
  }
  set isPeriodicSaveEnabled(isPeriodicSaveEnabled) {
    this.settings.isPeriodicSaveEnabled = isPeriodicSaveEnabled;
    this.saveSettings();
  }
  get periodicSaveInterval() {
    return this.settings.periodicSaveInterval;
  }
  set periodicSaveInterval(periodicSaveInterval) {
    this.settings.periodicSaveInterval = periodicSaveInterval;
    this.saveSettings();
  }
  get isSaveToGistEnabled() {
    return this.settings.isSaveToGistEnabled;
  }
  set isSaveToGistEnabled(isSaveToGistEnabled) {
    this.settings.isSaveToGistEnabled = isSaveToGistEnabled;
    this.saveSettings();
  }
  get isSaveToFileEnabled() {
    return this.settings.isSaveToFileEnabled;
  }
  set isSaveToFileEnabled(isSaveToFileEnabled) {
    this.settings.isSaveToFileEnabled = isSaveToFileEnabled;
    this.saveSettings();
  }
  get savePath() {
    return this.settings.savePath;
  }
  set savePath(savePath) {
    this.settings.savePath = savePath;
    this.saveSettings();
  }
  get saveFileName() {
    return this.settings.saveFileName;
  }
  set saveFileName(saveFileName) {
    this.settings.saveFileName = saveFileName;
    this.saveSettings();
  }
  get saveFileExtension() {
    return this.settings.saveFileExtension;
  }
  set saveFileExtension(saveFileExtension) {
    this.settings.saveFileExtension = saveFileExtension;
    this.saveSettings();
  }
  get howToParseInternalLinks() {
    return this.settings.howToParseInternalLinks;
  }
  set howToParseInternalLinks(howToParseInternalLinks) {
    this.settings.howToParseInternalLinks = howToParseInternalLinks;
    this.saveSettings();
  }
  get ignoreCompletedTasks() {
    return this.settings.ignoreCompletedTasks;
  }
  set ignoreCompletedTasks(ignoreCompletedTasks) {
    this.settings.ignoreCompletedTasks = ignoreCompletedTasks;
    this.saveSettings();
  }
  get isDebug() {
    return this.settings.isDebug;
  }
  set isDebug(isDebug) {
    this.settings.isDebug = isDebug;
    this.saveSettings();
  }
  get ignoreOldTasks() {
    return this.settings.ignoreOldTasks;
  }
  set ignoreOldTasks(ignoreOldTasks) {
    this.settings.ignoreOldTasks = ignoreOldTasks;
    this.saveSettings();
  }
  get oldTaskInDays() {
    return this.settings.oldTaskInDays;
  }
  set oldTaskInDays(oldTaskInDays) {
    this.settings.oldTaskInDays = oldTaskInDays;
    this.saveSettings();
  }
  get howToProcessMultipleDates() {
    return this.settings.howToProcessMultipleDates;
  }
  set howToProcessMultipleDates(howToProcessMultipleDates) {
    this.settings.howToProcessMultipleDates = howToProcessMultipleDates;
    this.saveSettings();
  }
  get includeEventsOrTodos() {
    return this.settings.includeEventsOrTodos;
  }
  set includeEventsOrTodos(includeEventsOrTodos) {
    this.settings.includeEventsOrTodos = includeEventsOrTodos;
    this.saveSettings();
  }
  get isOnlyTasksWithoutDatesAreTodos() {
    return this.settings.isOnlyTasksWithoutDatesAreTodos;
  }
  set isOnlyTasksWithoutDatesAreTodos(isOnlyTasksWithoutDatesAreTodos) {
    this.settings.isOnlyTasksWithoutDatesAreTodos = isOnlyTasksWithoutDatesAreTodos;
    this.saveSettings();
  }
  get isDayPlannerPluginFormatEnabled() {
    return this.settings.isDayPlannerPluginFormatEnabled;
  }
  set isDayPlannerPluginFormatEnabled(isDayPlannerPluginFormatEnabled) {
    this.settings.isDayPlannerPluginFormatEnabled = isDayPlannerPluginFormatEnabled;
    this.saveSettings();
  }
  get isIncludeTasksWithTags() {
    return this.settings.isIncludeTasksWithTags;
  }
  set isIncludeTasksWithTags(isIncludeTasksWithTags) {
    this.settings.isIncludeTasksWithTags = isIncludeTasksWithTags;
    this.saveSettings();
  }
  get includeTasksWithTags() {
    return this.settings.includeTasksWithTags;
  }
  set includeTasksWithTags(includeTasksWithTags) {
    this.settings.includeTasksWithTags = includeTasksWithTags;
    this.saveSettings();
  }
  get isExcludeTasksWithTags() {
    return this.settings.isExcludeTasksWithTags;
  }
  set isExcludeTasksWithTags(isExcludeTasksWithTags) {
    this.settings.isExcludeTasksWithTags = isExcludeTasksWithTags;
    this.saveSettings();
  }
  get excludeTasksWithTags() {
    return this.settings.excludeTasksWithTags;
  }
  set excludeTasksWithTags(excludeTasksWithTags) {
    this.settings.excludeTasksWithTags = excludeTasksWithTags;
    this.saveSettings();
  }
  get rootPath() {
    return this.settings.rootPath;
  }
  set rootPath(rootPath) {
    this.settings.rootPath = rootPath;
    this.saveSettings();
  }
  get isIncludeLinkInDescription() {
    return this.settings.isIncludeLinkInDescription;
  }
  set isIncludeLinkInDescription(isIncludeLinkInDescription) {
    this.settings.isIncludeLinkInDescription = isIncludeLinkInDescription;
    this.saveSettings();
  }
  get secretKey() {
    return this.settings.secretKey;
  }
  set secretKey(secretKey) {
    this.settings.secretKey = secretKey;
    this.saveSettings();
  }
  get isSaveToWebEnabled() {
    return this.settings.isSaveToWebEnabled;
  }
  set isSaveToWebEnabled(isSaveToWebEnabled) {
    this.settings.isSaveToWebEnabled = isSaveToWebEnabled;
    this.saveSettings();
  }
};
var settings = SettingsManager.settingsManager;
async function initSettingsManager(plugin) {
  settings = await SettingsManager.createInstance(plugin);
  return settings;
}

// src/FileClient.ts
var FileClient = class {
  constructor(vault) {
    this.vault = vault;
  }
  async save(calendar) {
    var _a;
    const fileRelativePath = `${(_a = settings.savePath) != null ? _a : settings.savePath + "/"}${settings.saveFileName}${settings.saveFileExtension}`;
    const file = this.vault.getAbstractFileByPath(fileRelativePath);
    if (file instanceof import_obsidian3.TFile) {
      log("File exists: updating");
      await this.vault.modify(file, calendar);
    } else {
      log("File does not exist: creating");
      await this.vault.create(fileRelativePath, calendar);
    }
  }
};

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
      else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-bundle/index.js
var import_fast_content_type_parse = __toESM(require_fast_content_type_parse(), 1);

// node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          /(?<! ) .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  var _a, _b, _c, _d, _e;
  const fetch = ((_a = requestOptions.request) == null ? void 0 : _a.fetch) || globalThis.fetch;
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  const log2 = ((_b = requestOptions.request) == null ? void 0 : _b.log) || console;
  const parseSuccessResponseBody = ((_c = requestOptions.request) == null ? void 0 : _c.parseSuccessResponseBody) !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name, value]) => [
      name,
      String(value)
    ])
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: (_d = requestOptions.request) == null ? void 0 : _d.redirect,
      headers: requestHeaders,
      signal: (_e = requestOptions.request) == null ? void 0 : _e.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  var _a;
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || ((_a = mimetype.parameters.charset) == null ? void 0 : _a.toLowerCase()) === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, defaults_default);

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType",
  "operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "7.0.2";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5 = "6.0.0";

// node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request2, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path2 = requestOptions.url.replace(options.baseUrl, "");
    return request2(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(
        `${requestOptions.method} ${path2} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      return response;
    }).catch((error) => {
      var _a;
      const requestId = ((_a = error.response) == null ? void 0 : _a.headers["x-github-request-id"]) || "UNKNOWN";
      octokit.log.error(
        `${requestOptions.method} ${path2} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`
      );
      throw error;
    });
  });
}
requestLog.VERSION = VERSION5;

// node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
var VERSION6 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data) || "total_commits" in response.data;
  if (!responseNeedsNormalization) return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  const totalCommits = response.data.total_commits;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  delete response.data.total_commits;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  response.data.total_commits = totalCommits;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^<>]+)>;\s*rel="next"/
          ) || [])[1];
          if (!url && "total_commits" in normalizedResponse.data) {
            const parsedUrl = new URL(normalizedResponse.url);
            const params = parsedUrl.searchParams;
            const page = parseInt(params.get("page") || "1", 10);
            const per_page = parseInt(params.get("per_page") || "250", 10);
            if (page * per_page < normalizedResponse.data.total_commits) {
              params.set("page", String(page + 1));
              url = parsedUrl.toString();
            }
          }
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409) throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION6;

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7 = "16.0.0";

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addRepoAccessToSelfHostedRunnerGroupInOrg: [
      "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
    createOrUpdateEnvironmentSecret: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    deleteHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    getHostedRunnersGithubOwnedImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
    ],
    getHostedRunnersLimitsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/limits"
    ],
    getHostedRunnersMachineSpecsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
    ],
    getHostedRunnersPartnerImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/partner"
    ],
    getHostedRunnersPlatformsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/platforms"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    listGithubHostedRunnersInGroupForOrg: [
      "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
    ],
    listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    updateHostedRunnerForOrg: [
      "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubBillingUsageReportOrg: [
      "GET /organizations/{org}/settings/billing/usage"
    ],
    getGithubBillingUsageReportUser: [
      "GET /users/{username}/settings/billing/usage"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  campaigns: {
    createCampaign: ["POST /orgs/{org}/campaigns"],
    deleteCampaign: ["DELETE /orgs/{org}/campaigns/{campaign_number}"],
    getCampaignSummary: ["GET /orgs/{org}/campaigns/{campaign_number}"],
    listOrgCampaigns: ["GET /orgs/{org}/campaigns"],
    updateCampaign: ["PATCH /orgs/{org}/campaigns/{campaign_number}"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    commitAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
    ],
    createAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    createVariantAnalysis: [
      "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
    ],
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    deleteCodeqlDatabase: [
      "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getAutofix: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    getVariantAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
    ],
    getVariantAnalysisRepoTask: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
    ],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codeSecurity: {
    attachConfiguration: [
      "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
    ],
    attachEnterpriseConfiguration: [
      "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
    ],
    createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
    createConfigurationForEnterprise: [
      "POST /enterprises/{enterprise}/code-security/configurations"
    ],
    deleteConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    deleteConfigurationForEnterprise: [
      "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    detachConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/detach"
    ],
    getConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    getConfigurationForRepository: [
      "GET /repos/{owner}/{repo}/code-security-configuration"
    ],
    getConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations"
    ],
    getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
    getDefaultConfigurations: [
      "GET /orgs/{org}/code-security/configurations/defaults"
    ],
    getDefaultConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/defaults"
    ],
    getRepositoriesForConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
    ],
    getRepositoriesForEnterpriseConfiguration: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
    ],
    getSingleConfigurationForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    setConfigurationAsDefault: [
      "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
    ],
    setConfigurationAsDefaultForEnterprise: [
      "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
    ],
    updateConfiguration: [
      "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    updateEnterpriseConfiguration: [
      "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
    copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  credentials: { revoke: ["POST /credentials/revoke"] },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  hostedCompute: {
    createNetworkConfigurationForOrg: [
      "POST /orgs/{org}/settings/network-configurations"
    ],
    deleteNetworkConfigurationFromOrg: [
      "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkConfigurationForOrg: [
      "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkSettingsForOrg: [
      "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
    ],
    listNetworkConfigurationsForOrg: [
      "GET /orgs/{org}/settings/network-configurations"
    ],
    updateNetworkConfigurationForOrg: [
      "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    addSubIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    listSubIssues: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    removeSubIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
    ],
    reprioritizeSubIssue: [
      "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
      }
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createIssueType: ["POST /orgs/{org}/issue-types"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}",
      {},
      {
        deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
      }
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
    getOrgRulesetVersion: [
      "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listIssueTypes: ["GET /orgs/{org}/issue-types"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: [
      "GET /orgs/{org}/security-managers",
      {},
      {
        deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
      }
    ],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
      }
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  privateRegistries: {
    createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
    deleteOrgPrivateRegistry: [
      "DELETE /orgs/{org}/private-registries/{secret_name}"
    ],
    getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
    listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
    updateOrgPrivateRegistry: [
      "PATCH /orgs/{org}/private-registries/{secret_name}"
    ]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkPrivateVulnerabilityReporting: [
      "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesetHistory: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
    ],
    getRepoRulesetVersion: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAttestations: [
      "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
    ],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: [
      "GET /search/issues",
      {},
      {
        deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
      }
    ],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    createPushProtectionBypass: [
      "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getById: ["GET /user/{account_id}"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION7;

// node_modules/@octokit/rest/dist-src/version.js
var VERSION8 = "22.0.0";

// node_modules/@octokit/rest/dist-src/index.js
var Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults(
  {
    userAgent: `octokit-rest.js/${VERSION8}`
  }
);

// src/GithubClient.ts
var GithubClient = class {
  constructor() {
    this.octokit = new Octokit2({
      auth: settings.githubPersonalAccessToken
    });
  }
  async save(calendar) {
    const f = settings.filename;
    const options = {
      gist_id: settings.githubGistId,
      files: {
        [f]: {
          content: calendar
        }
      }
    };
    await this.octokit.rest.gists.update(options);
  }
};

// src/ApiClient.ts
var import_obsidian4 = require("obsidian");

// src/Model/Api/ValidateResponse.ts
var SubscriptionStatus = /* @__PURE__ */ ((SubscriptionStatus2) => {
  SubscriptionStatus2["ACTIVE"] = "active";
  SubscriptionStatus2["CANCELED"] = "canceled";
  SubscriptionStatus2["INCOMPLETE"] = "incomplete";
  SubscriptionStatus2["INCOMPLETE_EXPIRED"] = "incomplete_expired";
  SubscriptionStatus2["PAST_DUE"] = "past_due";
  SubscriptionStatus2["PAUSED"] = "paused";
  SubscriptionStatus2["TRIALING"] = "trialing";
  SubscriptionStatus2["UNPAID"] = "unpaid";
  return SubscriptionStatus2;
})(SubscriptionStatus || {});
var ApiErrorResponse = class {
  constructor(data) {
    log("ApiErrorResponse:", data);
    this.error = data.error.toString();
    this.message = data.message.toString();
    this.code = data.code;
  }
};
var ApiValidateResponse = class _ApiValidateResponse {
  constructor(data) {
    log("ApiValidateResponseData:", data);
    this.status = this.parseStatus(data.data.subscription.status);
    this.expiresAt = data.data.subscription.expiresAt ? new Date(data.data.subscription.expiresAt) : null;
    this.message = data.message;
  }
  parseStatus(status) {
    const normalizedStatus = status.toLowerCase();
    if (Object.values(SubscriptionStatus).includes(normalizedStatus)) {
      return normalizedStatus;
    }
    log(`Unrecognized subscription status:`, status);
    return "canceled" /* CANCELED */;
  }
  isSubscriptionActive() {
    return this.status === "active" /* ACTIVE */;
  }
  // isTokenValid(): boolean {
  //   return this.valid;
  // }
  static fromJson(json) {
    const data = JSON.parse(json);
    try {
      return new _ApiValidateResponse(data);
    } catch (error) {
      console.error("Failed to parse ApiValidateResponse:", error);
      return new ApiErrorResponse(data);
    }
  }
  static fromResponse(response) {
    return new _ApiValidateResponse(response.json);
  }
};

// src/Model/Api/SaveResponse.ts
var ApiSaveResponse = class _ApiSaveResponse {
  constructor(data) {
    log("ApiSaveResponse:", data);
    this.url = data.data.calendar.url;
    this.updatedAt = data.data.calendar.updatedAt;
    this.message = data.message;
  }
  // getUrl(): string {
  //   return this.status === SubscriptionStatus.ACTIVE;
  // }
  //
  // isTokenValid(): boolean {
  //   return this.valid;
  // }
  static fromJson(json) {
    const data = JSON.parse(json);
    try {
      return new _ApiSaveResponse(data);
    } catch (error) {
      console.error("Failed to parse ApiValidateResponse:", error);
      return new ApiErrorResponse(data);
    }
  }
  static fromResponse(response) {
    return new _ApiSaveResponse(response.json);
  }
};

// src/Model/Api/GetCalendarResponse.ts
var ApiGetCalendarResponse = class _ApiGetCalendarResponse {
  constructor(data) {
    var _a;
    log("ApiGetCalendarResponse:", data);
    if ((_a = data.data) == null ? void 0 : _a.calendar) {
      this.url = data.data.calendar.url;
      this.updatedAt = data.data.calendar.updatedAt;
      this.vaultName = data.data.calendar.vaultName;
      this.found = true;
    } else {
      this.url = null;
      this.updatedAt = null;
      this.vaultName = null;
      this.found = false;
    }
    this.message = data.message;
  }
  static fromJson(json) {
    const data = JSON.parse(json);
    try {
      return new _ApiGetCalendarResponse(data);
    } catch (error) {
      console.error("Failed to parse ApiGetCalendarResponse:", error);
      return new ApiErrorResponse(data);
    }
  }
  static fromResponse(response) {
    return new _ApiGetCalendarResponse(response.json);
  }
};

// src/Model/Exception/ApiKeyMissingException.ts
var ApiKeyMissingException = class _ApiKeyMissingException extends Error {
  constructor(message = "Secret Key is required") {
    super(message);
    this.name = "ApiKeyMissingException";
    Object.setPrototypeOf(this, _ApiKeyMissingException.prototype);
  }
  static fromResponse(response) {
    var _a;
    const message = ((_a = response == null ? void 0 : response.json) == null ? void 0 : _a.message) || "Secret Key is required";
    return new _ApiKeyMissingException(message);
  }
};

// src/Model/Exception/InvalidUserException.ts
var InvalidUserException = class _InvalidUserException extends Error {
  constructor(message = "Invalid user") {
    super(message);
    this.name = "InvalidUserException";
    Object.setPrototypeOf(this, _InvalidUserException.prototype);
  }
  static fromResponse(response) {
    var _a;
    const message = ((_a = response == null ? void 0 : response.json) == null ? void 0 : _a.message) || "Invalid user";
    return new _InvalidUserException(message);
  }
};

// src/Model/Exception/NoActiveSubscriptionException.ts
var NoActiveSubscriptionException = class _NoActiveSubscriptionException extends Error {
  constructor(message = "No active subscription") {
    super(message);
    this.name = "NoActiveSubscriptionException";
    Object.setPrototypeOf(this, _NoActiveSubscriptionException.prototype);
  }
  static fromResponse(response) {
    var _a;
    const message = ((_a = response == null ? void 0 : response.json) == null ? void 0 : _a.message) || "No active subscription";
    return new _NoActiveSubscriptionException(message);
  }
};

// src/ValidationCache.ts
var ValidationCache = class _ValidationCache {
  // 5 minutes
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION_MS = 5 * 60 * 1e3;
  }
  static getInstance() {
    if (!_ValidationCache.instance) {
      _ValidationCache.instance = new _ValidationCache();
    }
    return _ValidationCache.instance;
  }
  /**
   * Get cached validation response if still valid
   */
  getCachedResponse(secretKey) {
    const cacheKey = this.getCacheKey(secretKey);
    const cached = this.cache.get(cacheKey);
    if (!cached) {
      log("ValidationCache: No cached response found");
      return null;
    }
    const now = Date.now();
    const isExpired = now - cached.timestamp > this.CACHE_DURATION_MS;
    if (isExpired) {
      log("ValidationCache: Cached response expired, removing from cache");
      this.cache.delete(cacheKey);
      return null;
    }
    log("ValidationCache: Returning cached response", {
      cachedAt: new Date(cached.timestamp),
      expiresAt: new Date(cached.timestamp + this.CACHE_DURATION_MS),
      isActive: cached.response.isSubscriptionActive()
    });
    return cached.response;
  }
  /**
   * Store validation response in cache
   */
  setCachedResponse(secretKey, response) {
    const cacheKey = this.getCacheKey(secretKey);
    const cached = {
      response,
      timestamp: Date.now()
    };
    this.cache.set(cacheKey, cached);
    log("ValidationCache: Stored response in cache", {
      isActive: response.isSubscriptionActive(),
      cachedAt: new Date(cached.timestamp),
      expiresAt: new Date(cached.timestamp + this.CACHE_DURATION_MS)
    });
  }
  /**
   * Check if cached response exists and is valid
   */
  isCacheValid(secretKey) {
    return this.getCachedResponse(secretKey) !== null;
  }
  /**
   * Clear cache for a specific secret key
   */
  clearCache(secretKey) {
    const cacheKey = this.getCacheKey(secretKey);
    this.cache.delete(cacheKey);
    log("ValidationCache: Cleared cache for secret key");
  }
  /**
   * Clear entire cache
   */
  clearAllCache() {
    this.cache.clear();
    log("ValidationCache: Cleared all cache");
  }
  /**
   * Get time remaining until cache expires (in ms)
   */
  getTimeUntilExpiry(secretKey) {
    const cacheKey = this.getCacheKey(secretKey);
    const cached = this.cache.get(cacheKey);
    if (!cached) {
      return 0;
    }
    const now = Date.now();
    const expiryTime = cached.timestamp + this.CACHE_DURATION_MS;
    const timeRemaining = Math.max(0, expiryTime - now);
    return timeRemaining;
  }
  getCacheKey(secretKey) {
    return `validation_${this.simpleHash(secretKey)}`;
  }
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
};

// src/ApiClient.ts
var ApiClient = class {
  constructor(vaultName, secretKey) {
    // apiBaseUrl: string = 'http://localhost/api';
    this.apiBaseUrl = "https://obsidian-ical.com/api";
    this.vaultName = vaultName;
    this.secretKey = secretKey;
    this.validationCache = ValidationCache.getInstance();
  }
  isActive(forceRefresh = false) {
    if (!forceRefresh) {
      const cachedResponse = this.validationCache.getCachedResponse(this.secretKey);
      if (cachedResponse) {
        log("Using cached validation response");
        return Promise.resolve(cachedResponse);
      }
    }
    log("Making fresh validation request to API");
    const response = (0, import_obsidian4.requestUrl)({
      url: `${this.apiBaseUrl}/validate`,
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.secretKey}`
      }
    }).then((response2) => {
      const validationResponse = ApiValidateResponse.fromResponse(response2);
      this.validationCache.setCachedResponse(this.secretKey, validationResponse);
      return validationResponse;
    }).catch((error) => {
      this.validationCache.clearCache(this.secretKey);
      return this.handleApiError(error);
    });
    log("response:", response);
    return response;
  }
  async save(calendar) {
    const cachedValidation = this.validationCache.getCachedResponse(this.secretKey);
    if (cachedValidation && !cachedValidation.isSubscriptionActive()) {
      log("Skipping save - cached validation shows inactive subscription");
      throw new NoActiveSubscriptionException("No active subscription (cached)");
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: `${this.apiBaseUrl}/save`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.secretKey}`
      },
      body: JSON.stringify({
        vaultName: this.vaultName,
        calendar
      })
    }).then((response2) => ApiSaveResponse.fromResponse(response2)).catch((error) => {
      this.validationCache.clearCache(this.secretKey);
      return this.handleApiError(error);
    });
    log("/api/save response:", response);
    return response;
  }
  /**
   * Check if validation is cached and still valid
   */
  isValidationCached() {
    return this.validationCache.isCacheValid(this.secretKey);
  }
  /**
   * Get cached validation response if available
   */
  getCachedValidation() {
    return this.validationCache.getCachedResponse(this.secretKey);
  }
  /**
   * Clear validation cache for current secret key
   */
  clearValidationCache() {
    this.validationCache.clearCache(this.secretKey);
  }
  /**
   * Get calendar for current vault
   */
  async getCalendar() {
    log("Getting calendar for vault:", this.vaultName);
    const response = await (0, import_obsidian4.requestUrl)({
      url: `${this.apiBaseUrl}/calendar/${encodeURIComponent(this.vaultName)}`,
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.secretKey}`
      }
    }).then((response2) => ApiGetCalendarResponse.fromResponse(response2)).catch((error) => {
      if (error.status === 404) {
        return new ApiGetCalendarResponse({
          data: null,
          message: "Calendar not found for this vault"
        });
      }
      return this.handleApiError(error);
    });
    log("/api/calendar response:", response);
    return response;
  }
  handleApiError(error) {
    var _a;
    if (error.status === 400 && ((_a = error.json) == null ? void 0 : _a.message)) {
      const message = error.json.message;
      if (message === "Secret Key is required") {
        throw ApiKeyMissingException.fromResponse(error);
      } else if (message === "Invalid user") {
        throw InvalidUserException.fromResponse(error);
      } else if (message === "No active subscription") {
        throw NoActiveSubscriptionException.fromResponse(error);
      }
    }
    throw error;
  }
};
function apiClient(vaultName, secretKey) {
  return new ApiClient(vaultName, secretKey);
}

// src/Model/TaskDate.ts
var TaskDate = class {
  constructor(date, name) {
    this.date = date;
    this.name = name;
  }
};
var TaskDateEmojiMap = {
  ["Created" /* Created */]: "\u2795",
  ["Scheduled" /* Scheduled */]: "\u23F3",
  ["Start" /* Start */]: "\u{1F6EB}",
  ["Due" /* Due */]: "\u{1F4C5}",
  ["Done" /* Done */]: "\u2705",
  ["Unknown" /* Unknown */]: "",
  ["TimeStart" /* TimeStart */]: "",
  ["TimeEnd" /* TimeEnd */]: ""
};
var EmojiToTaskDateNameMap = Object.entries(TaskDateEmojiMap).reduce(
  (acc, [key, emoji]) => {
    acc[emoji] = key;
    return acc;
  },
  {}
);
function getTaskNameFromEmoji(emoji) {
  var _a;
  return (_a = EmojiToTaskDateNameMap[emoji]) != null ? _a : "Unknown" /* Unknown */;
}
function convertDataviewToEmoji(markdown) {
  const dataviewFormatCreated = /\[created::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  const dataviewFormatScheduled = /\[scheduled::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  const dataviewFormatStart = /\[start::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  const dataviewFormatDue = /\[due::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  const dataviewFormatDone = /\[completion::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  const dataviewFormatCancelled = /\[cancelled::\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\s?\]/gi;
  markdown = markdown.replace(dataviewFormatCreated, (match, year, month, day) => {
    return `\u2795 ${year}-${month}-${day}`;
  });
  markdown = markdown.replace(dataviewFormatScheduled, (match, year, month, day) => {
    return `\u23F3 ${year}-${month}-${day}`;
  });
  markdown = markdown.replace(dataviewFormatStart, (match, year, month, day) => {
    return `\u{1F6EB} ${year}-${month}-${day}`;
  });
  markdown = markdown.replace(dataviewFormatDue, (match, year, month, day) => {
    return `\u{1F4C5} ${year}-${month}-${day}`;
  });
  markdown = markdown.replace(dataviewFormatDone, (match, year, month, day) => {
    return `\u2705 ${year}-${month}-${day}`;
  });
  markdown = markdown.replace(dataviewFormatCancelled, (match, year, month, day) => {
    return `\u274C ${year}-${month}-${day}`;
  });
  return markdown;
}
function getTaskDatesFromMarkdown(markdown, dateOverride) {
  markdown = convertDataviewToEmoji(markdown);
  if (dateOverride !== null) {
    const timeRegExp = /\b(\d{1,2}(?::\d{2})?(?::\d{2})?\s*[ap]m|\d{1,2}(?::\d{2})?(?::\d{2})?)(?:\s*-\s*(\d{1,2}(?::\d{2})?(?::\d{2})?\s*[ap]m|\d{1,2}(?::\d{2})?(?::\d{2})?))?\b/i;
    const match = markdown.match(timeRegExp);
    if (!match) {
      return [];
    }
    let timeStartString = match[1];
    let timeEndString = match[2];
    if (!timeEndString) {
      timeEndString = calculateEndTime(timeStartString);
    }
    const timeStart = createTimeDate(dateOverride, timeStartString);
    const timeEnd = createTimeDate(dateOverride, timeEndString);
    return [
      new TaskDate(timeStart, "TimeStart" /* TimeStart */),
      new TaskDate(timeEnd, "TimeEnd" /* TimeEnd */)
    ];
  }
  const dateRegExp = /(?<emoji>||||)?\s?(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\b/gi;
  const dateMatches = [...markdown.matchAll(dateRegExp)];
  const taskDates = dateMatches.filter((dateMatch) => {
    var _a, _b, _c;
    return ((_a = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _a.day) && ((_b = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _b.month) && ((_c = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _c.year);
  }).map((dateMatch) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const taskDateName = getTaskNameFromEmoji((_b = (_a = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _a.emoji) != null ? _b : "");
    const year = parseInt((_d = (_c = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _c.year) != null ? _d : "", 10);
    const monthIndex = parseInt((_f = (_e = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _e.month) != null ? _f : "", 10) - 1;
    const day = parseInt((_h = (_g = dateMatch == null ? void 0 : dateMatch.groups) == null ? void 0 : _g.day) != null ? _h : "", 10);
    const date = new Date(year, monthIndex, day);
    return new TaskDate(date, taskDateName);
  });
  return taskDates;
}
function calculateEndTime(startTime) {
  const isPM = startTime.toLowerCase().includes("pm");
  let [hour, minute] = startTime.replace(/(am|pm)/i, "").split(":").map(Number);
  if (isNaN(minute)) minute = 0;
  if (isPM && hour < 12) hour += 12;
  if (!isPM && hour === 12) hour = 0;
  let endMinute = minute + 30;
  let endHour = hour;
  if (endMinute >= 60) {
    endMinute -= 60;
    endHour += 1;
  }
  let endAMPM = "AM";
  if (endHour >= 12) {
    endAMPM = "PM";
    if (endHour > 12) {
      endHour -= 12;
    }
  }
  if (endHour === 0) {
    endHour = 12;
  }
  const endMinuteStr = endMinute.toString().padStart(2, "0");
  return `${endHour}:${endMinuteStr} ${endAMPM}`;
}
function createTimeDate(dateOverride, timeString) {
  const year = dateOverride.getFullYear();
  const month = dateOverride.getMonth();
  const day = dateOverride.getDate();
  const timeRegex = /(\d{1,2})(?::(\d{2}))?(?::(\d{2}))?\s*([ap]m)?/i;
  const match = timeString.match(timeRegex);
  if (!match) throw new Error("Invalid time format");
  let hour = parseInt(match[1], 10);
  const minute = match[2] ? parseInt(match[2], 10) : 0;
  const second = match[3] ? parseInt(match[3], 10) : 0;
  const amPmIndicator = match[4];
  if (amPmIndicator) {
    if (amPmIndicator.toLowerCase() === "pm" && hour < 12) hour += 12;
    if (amPmIndicator.toLowerCase() === "am" && hour === 12) hour = 0;
  }
  return new Date(year, month, day, hour, minute, second);
}
function hasTime(taskDate) {
  const startOfDay = new Date(taskDate.date);
  startOfDay.setHours(0, 0, 0, 0);
  return taskDate.date.getTime() !== startOfDay.getTime();
}

// src/Model/TaskStatus.ts
function getTaskStatusFromMarkdown(markdown) {
  switch (markdown) {
    case "[-]":
      return 3 /* Cancelled */;
    case "[/]":
    case "[d]":
      return 2 /* InProgress */;
    case "[x]":
    case "[X]":
      return 1 /* Done */;
    default:
      return 0 /* ToDo */;
  }
}
function getTaskStatusEmoji(taskStatus) {
  switch (taskStatus) {
    case 3 /* Cancelled */:
      return "\u{1F6AB}";
    case 1 /* Done */:
      return "\u2705";
    case 2 /* InProgress */:
      return "\u{1F3C3}";
    default:
      return "\u{1F532}";
  }
}

// src/IcalService.ts
var IcalService = class {
  getCalendar(tasks) {
    const includeEvents = settings.includeEventsOrTodos === "EventsAndTodos" || settings.includeEventsOrTodos === "EventsOnly";
    const includeTodos = settings.includeEventsOrTodos === "EventsAndTodos" || settings.includeEventsOrTodos === "TodosOnly";
    const events = includeEvents ? this.getEvents(tasks) : "";
    const toDos = includeTodos ? this.getToDos(tasks) : "";
    let calendar = "BEGIN:VCALENDAR\r\nVERSION:2.0\r\nPRODID:-//Andrew Brereton//obsidian-ical-plugin v2.0.1//EN\r\nX-WR-CALNAME:Obsidian Calendar\r\nNAME:Obsidian Calendar\r\nCALSCALE:GREGORIAN\r\n" + events + toDos + "END:VCALENDAR\r\n";
    calendar = this.pretty(calendar);
    return calendar;
  }
  getEvents(tasks) {
    return tasks.map((task) => {
      return this.getEvent(task, null, "");
    }).join("");
  }
  getEvent(task, date, prependSummary) {
    if (task.hasAnyDate() === false) {
      return "";
    }
    let event = "BEGIN:VEVENT\r\nUID:" + task.getId() + "\r\nDTSTAMP:" + task.getDate(null, "YYYYMMDDTHHmmss") + "\r\n";
    if (date === null) {
      switch (settings.howToProcessMultipleDates) {
        // User would prefer to use the task's start date
        // If a start date does not exist, take the due date
        // If a due date does not exist, take any old date that we can find
        case "PreferStartDate":
          if (task.hasA("Start" /* Start */)) {
            event += "DTSTART:" + task.getDate("Start" /* Start */, "YYYYMMDD") + "\r\n";
          } else if (task.hasA("Due" /* Due */)) {
            event += "DTSTART:" + task.getDate("Due" /* Due */, "YYYYMMDD") + "\r\n";
          } else if (task.hasA("TimeStart" /* TimeStart */) && task.hasA("TimeEnd" /* TimeEnd */)) {
            event += "DTSTART:" + task.getDate("TimeStart" /* TimeStart */, "YYYYMMDD[T]HHmmss[Z]") + "\r\n";
            event += "DTEND:" + task.getDate("TimeEnd" /* TimeEnd */, "YYYYMMDD[T]HHmmss[Z]") + "\r\n";
          } else {
            event += "DTSTART:" + task.getDate(null, "YYYYMMDD") + "\r\n";
          }
          break;
        // User would prefer to create an event per task date
        // If there is a start date, then create an event for it
        // If there is a schedule date, then create an event for it
        // If there is a due date, then create an event for it
        // If there are no events, then take any old date that we can find
        case "CreateMultipleEvents":
          event = "";
          if (task.hasA("Start" /* Start */)) {
            event += this.getEvent(task, task.getDate("Start" /* Start */, "YYYYMMDD"), "\u{1F6EB} ");
          }
          if (task.hasA("Scheduled" /* Scheduled */)) {
            event += this.getEvent(task, task.getDate("Scheduled" /* Scheduled */, "YYYYMMDD"), "\u23F3 ");
          }
          if (task.hasA("Due" /* Due */)) {
            event += this.getEvent(task, task.getDate("Due" /* Due */, "YYYYMMDD"), "\u{1F4C5} ");
          }
          if (event === "") {
            event += this.getEvent(task, task.getDate(null, "YYYYMMDD"), "");
          }
          return event;
        // User would prefer to use the task's due date
        // If there is a start and due date, set the start to the start date and the end to the due date
        // If a start and due date does not exist, take the due date
        // If a due date does not exist, take the start date
        // If a start date does not exist, take any old date that we can find
        case "PreferDueDate":
        default:
          if (task.hasA("Start" /* Start */) && task.hasA("Due" /* Due */)) {
            event += "DTSTART:" + task.getDate("Start" /* Start */, "YYYYMMDDTHHmmss") + "\r\nDTEND:" + task.getDate("Due" /* Due */, "YYYYMMDDTHHmmss") + "\r\n";
          } else if (task.hasA("Due" /* Due */)) {
            event += "DTSTART:" + task.getDate("Due" /* Due */, "YYYYMMDD") + "\r\n";
          } else if (task.hasA("Start" /* Start */)) {
            event += "DTSTART:" + task.getDate("Start" /* Start */, "YYYYMMDD") + "\r\n";
          } else if (task.hasA("TimeStart" /* TimeStart */) && task.hasA("TimeEnd" /* TimeEnd */)) {
            event += "DTSTART:" + task.getDate("TimeStart" /* TimeStart */, "YYYYMMDD[T]HHmmss[Z]") + "\r\n";
            event += "DTEND:" + task.getDate("TimeEnd" /* TimeEnd */, "YYYYMMDD[T]HHmmss[Z]") + "\r\n";
          } else {
            event += "DTSTART:" + task.getDate(null, "YYYYMMDD") + "\r\n";
          }
          break;
      }
    } else {
      event += "DTSTART:" + date + "\r\n";
    }
    event += "SUMMARY:" + prependSummary + task.getSummary() + "\r\n" + (settings.isIncludeLinkInDescription ? "DESCRIPTION:" + encodeURI(task.getLocation()) + "\r\n" : "") + 'LOCATION:ALTREP="' + encodeURI(task.getLocation()) + '":' + encodeURI(task.getLocation()) + "\r\nEND:VEVENT\r\n";
    return event;
  }
  getToDos(tasks) {
    return tasks.map((task) => {
      if (settings.isOnlyTasksWithoutDatesAreTodos && task.hasAnyDate() === true) {
        return "";
      }
      return this.getToDo(task);
    }).join("");
  }
  getToDo(task) {
    let toDo = "BEGIN:VTODO\r\nUID:" + task.getId() + "\r\nSUMMARY:" + task.getSummary() + "\r\n" + // If a task does not have a date, do not include the DTSTAMP property
    (task.hasAnyDate() ? "DTSTAMP:" + task.getDate(null, "YYYYMMDDTHHmmss") + "\r\n" : "") + 'LOCATION:ALTREP="' + encodeURI(task.getLocation()) + '":' + encodeURI(task.getLocation()) + "\r\n";
    if (task.hasA("Due" /* Due */)) {
      toDo += "DUE;VALUE=DATE:" + task.getDate("Due" /* Due */, "YYYYMMDD") + "\r\n";
    }
    if (task.hasA("Done" /* Done */)) {
      toDo += "COMPLETED;VALUE=DATE:" + task.getDate("Done" /* Done */, "YYYYMMDD") + "\r\n";
    }
    switch (task.status) {
      case 0 /* ToDo */:
        toDo += "STATUS:NEEDS-ACTION\r\n";
        break;
      case 2 /* InProgress */:
        toDo += "STATUS:IN-PROCESS\r\n";
        break;
      case 1 /* Done */:
        toDo += "STATUS:COMPLETED\r\n";
        break;
      case 3 /* Cancelled */:
        toDo += "STATUS:CANCELLED\r\n";
        break;
    }
    if (settings.isIncludeLinkInDescription) {
      toDo += "DESCRIPTION:" + encodeURI(task.getLocation()) + "\r\n";
    }
    toDo += "END:VTODO\r\n";
    return toDo;
  }
  pretty(calendar) {
    calendar = calendar.replace("/R{2,}/", "\r\n");
    calendar = calendar.replace("~(*BSR_ANYCRLF)R~", "\r\n");
    calendar = Buffer.from(calendar, "utf8").toString("utf8");
    return calendar;
  }
};

// src/Model/Task.ts
var import_crypto = require("crypto");
var import_obsidian5 = require("obsidian");

// src/Model/TaskSummary.ts
function getSummaryFromMarkdown(markdown, howToParseInternalLinks) {
  markdown = removeRecurringDates(markdown);
  switch (howToParseInternalLinks) {
    case "KeepTitle":
      markdown = extractWikilinkTitles(markdown);
      markdown = removeBareWikilinks(markdown);
      markdown = extractMarkdownLinkTitles(markdown);
      break;
    case "PreferTitle":
      markdown = extractWikilinkTitles(markdown);
      markdown = extractWikilinkLinks(markdown);
      markdown = extractMarkdownLinkTitles(markdown);
      break;
    case "RemoveThem":
      markdown = removeWikilinks(markdown);
      markdown = removeMarkdownLinks(markdown);
      break;
    case "DoNotModifyThem":
    default:
  }
  markdown = removeEmojiDates(markdown);
  markdown = removeDataviewDates(markdown);
  markdown = removeDates(markdown);
  markdown = trimWhitespace(markdown);
  return markdown;
}
function extractWikilinkTitles(markdown) {
  const regExp = /\[\[[^\]]*\|+([^\]]+)\]\]/gi;
  markdown = markdown.replace(regExp, "$1");
  return markdown;
}
function removeBareWikilinks(markdown) {
  const regExp = /\[{2}([^|\]]+)\]{2}/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function extractMarkdownLinkTitles(markdown) {
  const regExp = /\[([^\]]+)\]\([^\)]+\)/gi;
  markdown = markdown.replace(regExp, "$1");
  return markdown;
}
function extractWikilinkLinks(markdown) {
  const regExp = /\[{2}(.*)\]{2}/gi;
  markdown = markdown.replace(regExp, "$1");
  return markdown;
}
function removeWikilinks(markdown) {
  const regExp = /\[{2}.*\]{2}/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function removeMarkdownLinks(markdown) {
  const regExp = /\[.*\]\(.*\)/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function removeRecurringDates(markdown) {
  const regExp = /(.*?)(?=\s(?:||||)|\s\d{4}-\d{2}-\d{2}|$)/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function removeEmojiDates(markdown) {
  const regExp = /\s*||||\s?\d{4}-\d{2}-\d{1,2}\s*/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function removeDataviewDates(markdown) {
  const regExp = /\s*\[(created|scheduled|start|due|completion|cancelled)::\s?\d{4}-\d{2}-\d{1,2}\s*\]/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function removeDates(markdown) {
  const regExp = /\s*\d{4}-\d{2}-\d{1,2}/gi;
  markdown = markdown.replace(regExp, "");
  return markdown;
}
function trimWhitespace(markdown) {
  const regExp = /\s{2,}}/gi;
  markdown = markdown.replace(regExp, " ");
  markdown = markdown.trim();
  return markdown;
}

// src/Model/Task.ts
var Task = class {
  constructor(status, dates, summary, fileUri) {
    this.status = status;
    this.dates = dates;
    this.summary = summary;
    this.fileUri = fileUri;
  }
  getId() {
    return crypto.randomUUID();
  }
  hasA(taskDateName) {
    return this.dates.some((taskDate) => {
      return taskDate.name === taskDateName;
    });
  }
  hasAnyDate() {
    return this.dates.length > 0;
  }
  getDate(taskDateName, format) {
    if (this.dates.length === 0) {
      return "";
    }
    if (taskDateName === null) {
      taskDateName = this.dates[0].name;
    }
    const matchingTaskDate = this.dates.find((taskDate) => {
      if (taskDate.name === taskDateName) {
        return taskDate.date;
      }
    });
    if (typeof matchingTaskDate === "undefined") {
      return "";
    }
    if (hasTime(matchingTaskDate)) {
      return (0, import_obsidian5.moment)(matchingTaskDate.date).format(format);
    } else {
      return (0, import_obsidian5.moment)(matchingTaskDate.date).format(format);
    }
  }
  getSummary() {
    const summary = this.summary.replace(/\\/gm, "\\\\").replace(/\r?\n/gm, "\\n").replace(/;/gm, "\\;").replace(/,/gm, "\\,");
    const emoji = getTaskStatusEmoji(this.status);
    return `${emoji} ${summary}`;
  }
  getLocation() {
    return this.fileUri;
  }
};
function createTaskFromLine(line, fileUri, dateOverride) {
  var _a, _b, _c, _d, _e, _f;
  const taskRegExp = /(\*|-)\s*(?<taskStatus>\[.?])\s*(?<summary>.*)\s*/gi;
  const dateRegExp = /\b(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\b/gi;
  const taskMatch = (_a = [...line.matchAll(taskRegExp)][0]) != null ? _a : null;
  if (taskMatch === null) {
    return null;
  }
  const dateMatch = (_b = [...line.matchAll(dateRegExp)][0]) != null ? _b : null;
  if (dateMatch === null && dateOverride === null && settings.includeEventsOrTodos === "EventsOnly") {
    return null;
  }
  const taskStatus = getTaskStatusFromMarkdown((_d = (_c = taskMatch == null ? void 0 : taskMatch.groups) == null ? void 0 : _c.taskStatus) != null ? _d : "");
  if (taskStatus === 1 /* Done */ && settings.ignoreCompletedTasks === true) {
    return null;
  }
  const taskDates = getTaskDatesFromMarkdown(line, dateOverride);
  if (settings.ignoreOldTasks === true) {
    const now = /* @__PURE__ */ new Date();
    const thresholdDate = new Date(now.setDate(now.getDate() - settings.oldTaskInDays));
    const isAllDatesOld = taskDates.every((taskDate) => {
      return taskDate.date < thresholdDate;
    });
    if (isAllDatesOld === true) {
      return null;
    }
  }
  const summary = getSummaryFromMarkdown((_f = (_e = taskMatch == null ? void 0 : taskMatch.groups) == null ? void 0 : _e.summary) != null ? _f : "", settings.howToParseInternalLinks);
  return new Task(taskStatus, taskDates, summary, fileUri);
}

// src/TaskFinder.ts
var TaskFinder = class {
  constructor(vault) {
    this.vault = vault;
  }
  async findTasks(file, listItemsCache, headings) {
    const fileCachedContent = await this.vault.cachedRead(file);
    const lines = fileCachedContent.split("\n");
    const fileUri = "obsidian://open?vault=" + file.vault.getName() + "&file=" + file.path;
    let dateOverride = null;
    const tasks = listItemsCache.map((markdownListItem) => {
      return markdownListItem.position.start.line;
    }).map((markdownLineNumber) => {
      return {
        "markdownLineNumber": markdownLineNumber,
        "markdownLine": lines[markdownLineNumber]
      };
    }).map((lineAndHeading) => {
      var _a;
      if (settings.isDayPlannerPluginFormatEnabled && (headings == null ? void 0 : headings.hasHeadings())) {
        if (this.hasTimes(lineAndHeading.markdownLine)) {
          const heading = headings.getHeadingForMarkdownLineNumber(lineAndHeading.markdownLineNumber);
          dateOverride = (_a = heading == null ? void 0 : heading.getDate) != null ? _a : null;
        }
      }
      if (settings.isIncludeTasksWithTags) {
        if (!this.hasTag(lineAndHeading.markdownLine, settings.includeTasksWithTags)) {
          return null;
        }
      }
      if (settings.isExcludeTasksWithTags) {
        if (this.hasTag(lineAndHeading.markdownLine, settings.excludeTasksWithTags)) {
          return null;
        }
      }
      return createTaskFromLine(lineAndHeading.markdownLine, fileUri, dateOverride);
    }).filter((task) => task !== null);
    return tasks;
  }
  hasTimes(line) {
    const timeRegExp = /\b((?<!\d{4}-\d{2}-)\d{1,2}:(\d{2})(?::\d{2})?\s*(?:[ap][m])?|(?<!\d{4}-\d{2}-)\d{1,2}\s*[ap][m])\b/gi;
    return timeRegExp.test(line);
  }
  // Does this line contain any of the tags provided?
  hasTag(line, tags) {
    if (!tags.includes(" ")) {
      return line.includes(tags);
    }
    return tags.split(" ").some((tag) => line.includes(tag));
  }
};

// src/Model/Heading.ts
var Heading = class {
  constructor(date, line) {
    this.date = date;
    this.line = line;
  }
  get getDate() {
    return this.date;
  }
  get getLine() {
    return this.line;
  }
};

// src/Model/Headings.ts
var Headings = class {
  constructor(markdownHeadings) {
    this.headings = [];
    this.setHeadings(markdownHeadings);
  }
  setHeadings(markdownHeadings) {
    markdownHeadings.forEach((markdownHeading) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const dateRegExp = /\b(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{1,2})\b/gi;
      const dateMatches = [...markdownHeading.heading.matchAll(dateRegExp)][0];
      if (typeof dateMatches === "undefined") {
        return null;
      }
      const line = (_a = markdownHeading.position.start.line) != null ? _a : 0;
      const year = parseInt((_c = (_b = dateMatches == null ? void 0 : dateMatches.groups) == null ? void 0 : _b.year) != null ? _c : "", 10);
      const monthIndex = parseInt((_e = (_d = dateMatches == null ? void 0 : dateMatches.groups) == null ? void 0 : _d.month) != null ? _e : "", 10) - 1;
      const day = parseInt((_g = (_f = dateMatches == null ? void 0 : dateMatches.groups) == null ? void 0 : _f.day) != null ? _g : "", 10);
      const date = new Date(year, monthIndex, day);
      this.addHeading(new Heading(date, line));
    });
  }
  addHeading(heading) {
    const insertIndex = this.headings.findIndex((h) => h.getLine < heading.getLine);
    if (insertIndex === -1) {
      this.headings.push(heading);
    } else {
      this.headings.splice(insertIndex, 0, heading);
    }
  }
  hasHeadings() {
    return this.headings.length > 0;
  }
  getHeadingForMarkdownLineNumber(markdownLineNumber) {
    return this.headings.find((heading) => heading.getLine <= markdownLineNumber);
  }
};

// src/Main.ts
var Main = class {
  constructor(app) {
    this.app = app;
    this.iCalService = new IcalService();
    this.githubClient = new GithubClient();
    this.apiClient = new ApiClient(app.vault.getName(), settings.secretKey);
    this.fileClient = new FileClient(this.app.vault);
    this.tasks = [];
    this.taskFinder = new TaskFinder(this.app.vault);
  }
  async start() {
    var _a, _b, _c, _d;
    let markdownFiles = this.app.vault.getMarkdownFiles();
    if (settings.rootPath !== "/") {
      markdownFiles = markdownFiles.filter(
        (file) => file.path.startsWith(settings.rootPath)
      );
    }
    const taskPromises = [];
    log("Performing a scan");
    log("Settings", { settings: settings.settingsWithoutSecrets() });
    log(`Found ${markdownFiles.length} Markdown files in ${settings.rootPath}`, { markdownFiles, settings });
    for (const file of markdownFiles) {
      if (this.isSyncthingConflictFile(file.name)) {
        log("SyncThing sync conflict file. Skipping", file);
        continue;
      }
      const listItemsCache = (_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.listItems) != null ? _b : [];
      if (listItemsCache.length) {
        let headings;
        if (settings.isDayPlannerPluginFormatEnabled) {
          const markdownHeadings = (_d = (_c = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _c.headings) != null ? _d : [];
          if (markdownHeadings.length) {
            headings = new Headings(markdownHeadings);
          }
        }
        const tasks = await this.taskFinder.findTasks(file, listItemsCache, headings);
        taskPromises.push(tasks);
      }
    }
    const allTasks = await Promise.all(taskPromises);
    this.tasks = [];
    allTasks.forEach((tasks) => {
      tasks.forEach((task) => {
        this.tasks.push(task);
      });
    });
    log(`Found ${this.tasks.length} tasks`, this.tasks);
    const calendar = this.iCalService.getCalendar(this.tasks);
    log("Calendar has been built", { calendar });
    if (settings.isSaveToGistEnabled) {
      log("Saving calendar to Gist...");
      await this.saveToGist(calendar);
      log("Done");
    } else {
      log("Skip saving calendar to Gist");
    }
    if (settings.isSaveToFileEnabled) {
      log("Saving calendar to file...");
      await this.saveToFile(calendar);
      log("Done");
    } else {
      log("Skip saving calendar to file");
    }
    if (settings.isSaveToWebEnabled) {
      log("Saving calendar to web...");
      await this.saveToWeb(calendar);
      log("Done");
    } else {
      log("Skip saving calendar to web");
    }
  }
  async saveToGist(calendar) {
    await this.githubClient.save(calendar);
  }
  async saveToFile(calendar) {
    await this.fileClient.save(calendar);
  }
  async saveToWeb(calendar) {
    const response = await this.apiClient.save(calendar);
    log("Calendar saved to web successfully:", response.url);
    return response;
  }
  isSyncthingConflictFile(filename) {
    const regExp = /.+\.sync-conflict-.+\.md/gi;
    return regExp.test(filename);
  }
};

// src/SettingTab.ts
var import_obsidian6 = require("obsidian");
var path = __toESM(require("path"));
var SettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.isSecretKeyValid = false;
    this.calendarUrl = null;
    this.subscriptionStatus = null;
    this.subscriptionExpiresAt = null;
    this.calendarUpdatedAt = null;
    this.plugin = plugin;
  }
  // This function returns all of the directories in the current vault
  async getAllDirectories() {
    const files = this.app.vault.getAllLoadedFiles();
    const directories = files.filter((file) => file instanceof import_obsidian6.TFolder).map((folder) => folder.path).sort((a, b) => a.localeCompare(b, void 0, { sensitivity: "base" }));
    return directories;
  }
  clearMemberStatus() {
    this.isSecretKeyValid = false;
    this.subscriptionStatus = null;
    this.subscriptionExpiresAt = null;
    this.calendarUrl = null;
    this.calendarUpdatedAt = null;
  }
  updateMemberStatusFromCache() {
    var _a;
    if (!settings.secretKey || settings.secretKey.length !== 32) {
      this.clearMemberStatus();
      return;
    }
    const client = apiClient(this.app.vault.getName(), settings.secretKey);
    const cachedValidation = client.getCachedValidation();
    if (cachedValidation) {
      this.isSecretKeyValid = cachedValidation.isSubscriptionActive();
      this.subscriptionStatus = cachedValidation.status;
      this.subscriptionExpiresAt = ((_a = cachedValidation.expiresAt) == null ? void 0 : _a.toISOString()) || null;
      client.getCalendar().then((calendarResponse) => {
        if (calendarResponse.found) {
          this.calendarUrl = calendarResponse.url;
          this.calendarUpdatedAt = calendarResponse.updatedAt;
        }
      }).catch(() => {
      });
    } else {
      this.validateSecretKeyInBackground(settings.secretKey);
    }
  }
  async validateSecretKeyInBackground(secretKey) {
    if (secretKey.length !== 32) {
      this.clearMemberStatus();
      return;
    }
    try {
      const client = apiClient(this.app.vault.getName(), secretKey);
      const response = await client.isActive(true);
      if (response.isSubscriptionActive()) {
        this.updateMemberStatusFromCache();
        await this.plugin.configureValidationRefresh();
        this.display();
      } else {
        this.clearMemberStatus();
      }
    } catch (error) {
      log("Background secret key validation failed:", error);
      this.clearMemberStatus();
    }
  }
  async validateSecretKey(secretKey) {
    if (secretKey.length !== 32) {
      return;
    }
    try {
      const client = apiClient(this.app.vault.getName(), secretKey);
      client.clearValidationCache();
      const response = await client.isActive(true);
      if (response.isSubscriptionActive()) {
        this.updateMemberStatusFromCache();
        await this.plugin.configureValidationRefresh();
      }
    } catch (error) {
      log("Secret key validation failed:", error);
    }
  }
  async display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    this.updateMemberStatusFromCache();
    containerEl.createEl("p", {
      text: createFragment((fragment) => {
        fragment.append("This plugin finds all of the ");
        fragment.append(fragment.createEl("a", {
          text: "Task Lists",
          title: "Link to Task Lists on on obsidian.md (https://help.obsidian.md/syntax#Task+lists)",
          href: "https://help.obsidian.md/syntax#Task+lists",
          cls: "search-result und"
        }));
        fragment.append(" in your vault that contain a date and generates a calendar in iCalendar format. Your calendar can be saved and imported into your preferred calendar application.");
      })
    });
    containerEl.createEl("h2", { text: "Quick Start & Essential Settings" });
    const directories = await this.getAllDirectories();
    new import_obsidian6.Setting(containerEl).setName("Target directory").setDesc('Specify where we should look for tasks. Choose "/" to look in the whole vault.').addDropdown(
      (dropdown) => {
        directories.forEach((dir) => {
          dropdown.addOption(dir, dir);
        });
        dropdown.onChange(async (value) => {
          value = (0, import_obsidian6.normalizePath)(value);
          settings.rootPath = value;
        });
        return dropdown;
      }
    );
    containerEl.createEl("h3", { text: "Save Destinations" });
    new import_obsidian6.Setting(containerEl).setName("Save calendar to disk?").addToggle(
      (toggle) => toggle.setValue(settings.isSaveToFileEnabled).onChange(async (value) => {
        settings.isSaveToFileEnabled = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Save calendar to GitHub Gist?").addToggle(
      (toggle) => toggle.setValue(settings.isSaveToGistEnabled).onChange(async (value) => {
        settings.isSaveToGistEnabled = value;
        this.display();
      })
    );
    containerEl.createEl("h3", { text: "Member Area" });
    containerEl.createEl("p", {
      cls: "setting-item-description",
      text: createFragment((fragment) => {
        fragment.append("Optionally, you can become a member to unlock more features such as calendar hosting. ");
        fragment.append(fragment.createEl("a", {
          text: "Create an account on obsidian-ical.com",
          href: "https://obsidian-ical.com/",
          cls: "search-result"
        }));
      })
    });
    new import_obsidian6.Setting(containerEl).setName("Secret Key").setDesc(createFragment((fragment) => {
      fragment.append("Copy and paste your ");
      fragment.append(fragment.createEl("a", {
        text: "Secret Key",
        href: "https://obsidian-ical.com/member/secret-key",
        cls: "search-result"
      }));
      fragment.append(" here to unlock member features");
    })).addText(
      (text) => text.setValue(settings.secretKey.toString()).setPlaceholder(DEFAULT_SETTINGS.secretKey).onChange(async (secretKey) => {
        settings.secretKey = secretKey;
        this.clearMemberStatus();
        if (secretKey.length === 32) {
          await this.validateSecretKey(secretKey);
          this.display();
        }
      })
    );
    if (this.isSecretKeyValid) {
      containerEl.createEl("h4", { text: "Member Status", cls: "setting-item-name" });
      const subscriptionStatusText = this.subscriptionStatus === "active" ? "\u2705 Active" : this.subscriptionStatus === "trialing" ? "\u{1F193} Trial" : `\u26A0\uFE0F ${this.subscriptionStatus}`;
      new import_obsidian6.Setting(containerEl).setName("Subscription").setDesc(createFragment((fragment) => {
        fragment.createEl("span", { text: subscriptionStatusText });
        if (this.subscriptionExpiresAt) {
          const expiryDate = new Date(this.subscriptionExpiresAt);
          fragment.createEl("br");
          fragment.createEl("small", {
            text: `Renews: ${expiryDate.toLocaleDateString()}`,
            cls: "setting-item-description"
          });
        }
      }));
      if (this.calendarUrl) {
        new import_obsidian6.Setting(containerEl).setName("Calendar URL").setDesc(createFragment((fragment) => {
          fragment.createEl("a", {
            text: this.calendarUrl,
            href: this.calendarUrl,
            cls: "search-result"
          });
          if (this.calendarUpdatedAt) {
            const updatedDate = new Date(this.calendarUpdatedAt);
            fragment.createEl("br");
            fragment.createEl("small", {
              text: `Last updated: ${updatedDate.toLocaleString()}`,
              cls: "setting-item-description"
            });
          }
        })).addButton((button) => {
          button.setButtonText("\u{1F4CB} Copy to clipboard").onClick(() => {
            navigator.clipboard.writeText(this.calendarUrl);
            button.setButtonText("\u2705 Copied!");
            window.setTimeout(() => {
              button.setButtonText("\u{1F4CB} Copy to clipboard");
            }, 500);
          });
        });
      } else {
        containerEl.createEl("p", {
          cls: "setting-item-description",
          text: "\u{1F4C5} Your calendar URL will appear here after your first save to the web."
        });
      }
      containerEl.createEl("h4", { text: "Pro Settings", cls: "setting-item-name" });
      new import_obsidian6.Setting(containerEl).setName("Save calendar to the web").setDesc("Turning this on will save your calendar to your private area on https://obsidian-ical.com").addToggle(
        (toggle) => toggle.setValue(settings.isSaveToWebEnabled).onChange(async (value) => {
          settings.isSaveToWebEnabled = value;
          await this.plugin.configureValidationRefresh();
          this.display();
        })
      );
    }
    containerEl.createEl("h2", { text: "Task Processing" });
    new import_obsidian6.Setting(containerEl).setName("Ignore completed tasks?").setDesc("Choose if you want your calendar to ignore tasks that have been completed.").addToggle(
      (toggle) => toggle.setValue(settings.ignoreCompletedTasks).onChange(async (value) => {
        settings.ignoreCompletedTasks = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Add tasks as TODO items to your calendar").setDesc("Normally, we add your tasks as normal calendar events. You can choose to add your tasks as TODO items as well. Or you could add your tasks as calendar events as well as TODO items.").addDropdown(
      (dropdown) => dropdown.addOptions(INCLUDE_EVENTS_OR_TODOS).setValue(settings.includeEventsOrTodos).onChange(async (value) => {
        settings.includeEventsOrTodos = value;
        this.display();
      })
    );
    if (settings.includeEventsOrTodos === "EventsAndTodos" || settings.includeEventsOrTodos === "TodosOnly") {
      new import_obsidian6.Setting(containerEl).setName("Only tasks without dates are TODO items").setDesc("When adding the TODO items to your calendar, should we only consider tasks without dates as TODO items?").addToggle(
        (toggle) => toggle.setValue(settings.isOnlyTasksWithoutDatesAreTodos).onChange(async (value) => {
          settings.isOnlyTasksWithoutDatesAreTodos = value;
          this.display();
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Ignore old tasks?").setDesc("Do you want to exclude tasks if they are older than a certain age? This could be useful if you have a very large number of tasks and are not interested in the past.").addToggle(
      (toggle) => toggle.setValue(settings.ignoreOldTasks).onChange(async (value) => {
        settings.ignoreOldTasks = value;
        this.display();
      })
    );
    if (settings.ignoreOldTasks) {
      new import_obsidian6.Setting(containerEl).setName("How many days back to you want to keep old tasks?").setDesc("If every date for a given task is more than this many days ago then it will be excluded from your calendar.").addText(
        (text) => text.setValue(settings.oldTaskInDays.toString()).onChange(async (value) => {
          let days = parseInt(value, 10);
          if (days < 0) days = 1;
          if (days > 3650) days = 3650;
          settings.oldTaskInDays = days;
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Which task date should be used?").setDesc("A task can have many dates (eg: due, start, scheduled, etc). When multiple dates are encountered in a task, which date do you want to use for the calendar?").addDropdown(
      (dropdown) => dropdown.addOptions(HOW_TO_PROCESS_MULTIPLE_DATES).setValue(settings.howToProcessMultipleDates).onChange(async (value) => {
        settings.howToProcessMultipleDates = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Support Day Planner plugin?").setDesc("Turn this on if you want to support the Day Planner plugin format.").addToggle(
      (toggle) => toggle.setValue(settings.isDayPlannerPluginFormatEnabled).onChange(async (value) => {
        settings.isDayPlannerPluginFormatEnabled = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Save calendar to GitHub Gist?").addToggle(
      (toggle) => toggle.setValue(settings.isSaveToGistEnabled).onChange(async (value) => {
        settings.isSaveToGistEnabled = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Save calendar to disk?").addToggle(
      (toggle) => toggle.setValue(settings.isSaveToFileEnabled).onChange(async (value) => {
        settings.isSaveToFileEnabled = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Periodically save your calendar").setDesc("Do you want the plugin to periodically process your tasks? If you choose not to then a calendar will only be built when Obsidian is loaded.").addToggle(
      (toggle) => toggle.setValue(settings.isPeriodicSaveEnabled).onChange(async (value) => {
        settings.isPeriodicSaveEnabled = value;
        this.plugin.configurePeriodicSave();
        this.display();
      })
    );
    if (settings.isPeriodicSaveEnabled) {
      new import_obsidian6.Setting(containerEl).setName("How often should we parse and save your calendar? (minutes)").setDesc("How often do you want to periodically scan for tasks?").addText(
        (text) => text.setValue(settings.periodicSaveInterval.toString()).onChange(async (value) => {
          let minutes = parseInt(value, 10);
          if (minutes < 1) minutes = 1;
          if (minutes > 1440) minutes = 1440;
          settings.periodicSaveInterval = minutes;
          await this.plugin.configurePeriodicSave();
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Only include tasks with certain tags?").setDesc("Do you want your calendar to only include tasks that contain certain tags?").addToggle(
      (toggle) => toggle.setValue(settings.isIncludeTasksWithTags).onChange(async (value) => {
        settings.isIncludeTasksWithTags = value;
        this.display();
      })
    );
    if (settings.isIncludeTasksWithTags) {
      new import_obsidian6.Setting(containerEl).setName("Only include tasks that contain these tags").setDesc("Enter one or more tags. Separate multiple tags with a space. If one or more of these tags are found then the task will be included in your calendar.").addText(
        (text) => text.setValue(settings.includeTasksWithTags.toString()).setPlaceholder(DEFAULT_SETTINGS.includeTasksWithTags).onChange(async (includeTasksWithTags) => {
          includeTasksWithTags = this.cleanTags(includeTasksWithTags);
          settings.includeTasksWithTags = includeTasksWithTags;
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Exclude tasks with certain tags?").setDesc("Do you want your calendar to exclude tasks that contain certain tags?").addToggle(
      (toggle) => toggle.setValue(settings.isExcludeTasksWithTags).onChange(async (value) => {
        settings.isExcludeTasksWithTags = value;
        this.display();
      })
    );
    if (settings.isExcludeTasksWithTags) {
      new import_obsidian6.Setting(containerEl).setName("Exclude tasks that contain these tags").setDesc("Enter one or more tags. Separate multiple tags with a space. If one or more of these tags are found then the task will be excluded from your calendar.").addText(
        (text) => text.setValue(settings.excludeTasksWithTags.toString()).setPlaceholder(DEFAULT_SETTINGS.excludeTasksWithTags).onChange(async (excludeTasksWithTags) => {
          excludeTasksWithTags = this.cleanTags(excludeTasksWithTags);
          settings.excludeTasksWithTags = excludeTasksWithTags;
        })
      );
    }
    containerEl.createEl("h2", { text: "Automation & Advanced" });
    new import_obsidian6.Setting(containerEl).setName("Periodically save your calendar").setDesc("Do you want the plugin to periodically process your tasks? If you choose not to then a calendar will only be built when Obsidian is loaded.").addToggle(
      (toggle) => toggle.setValue(settings.isPeriodicSaveEnabled).onChange(async (value) => {
        settings.isPeriodicSaveEnabled = value;
        this.plugin.configurePeriodicSave();
        this.display();
      })
    );
    if (settings.isPeriodicSaveEnabled) {
      new import_obsidian6.Setting(containerEl).setName("How often should we parse and save your calendar? (minutes)").setDesc("How often do you want to periodically scan for tasks?").addText(
        (text) => text.setValue(settings.periodicSaveInterval.toString()).onChange(async (value) => {
          let minutes = parseInt(value, 10);
          if (minutes < 1) minutes = 1;
          if (minutes > 1440) minutes = 1440;
          settings.periodicSaveInterval = minutes;
          await this.plugin.configurePeriodicSave();
        })
      );
    }
    new import_obsidian6.Setting(containerEl).setName("Processing internal links").setDesc("How should [[wikilinks]] and [markdown links](markdown links) be processed if they are encountered in a task?").addDropdown(
      (dropdown) => dropdown.addOptions(HOW_TO_PARSE_INTERNAL_LINKS).setValue(settings.howToParseInternalLinks).onChange(async (value) => {
        settings.howToParseInternalLinks = value;
        this.display();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Add link to Obsidian in event description").setDesc("Include a link to open the task in Obsidian in the event description. This is useful for clients such as Thunderbird or Evolution.").addToggle(
      (toggle) => toggle.setValue(settings.isIncludeLinkInDescription).onChange(async (value) => {
        settings.isIncludeLinkInDescription = value;
        this.display();
      })
    );
    containerEl.createEl("h2", { text: "Save Destinations" });
    if (settings.isSaveToGistEnabled) {
      containerEl.createEl("h3", { text: "GitHub Gist Settings" });
      containerEl.createEl("p", { cls: "setting-item-description", text: "Perform the following steps to get your Personal Access Token and Gist ID:" });
      const ol = containerEl.createEl("ol");
      ol.createEl("li", { cls: "setting-item-description", text: "Go to https://github.com/settings/tokens/new and create a new personal access token. It only needs Gist scope." });
      ol.createEl("li", { cls: "setting-item-description", text: "Go to https://gist.github.com/ and create a new secret Gist." });
      containerEl.append(ol);
      new import_obsidian6.Setting(containerEl).setName("GitHub personal access token").setDesc("Used to privately store your calendar on Github").addText(
        (text) => text.setValue(settings.githubPersonalAccessToken).onChange(async (value) => {
          var _a2;
          try {
            this.validateGithubPersonalAccessToken(value);
            githubPersonalAccessTokenErrorElement.innerText = "";
            settings.githubPersonalAccessToken = value;
          } catch (error) {
            log("Error!", error);
            githubPersonalAccessTokenErrorElement.innerText = `${(_a2 = error.message) != null ? _a2 : "Unknown error"}`;
          }
        })
      );
      const githubPersonalAccessTokenErrorElement = containerEl.createEl("p", { text: "", cls: ["setting-message", "cm-negative"] });
      containerEl.append(githubPersonalAccessTokenErrorElement);
      new import_obsidian6.Setting(containerEl).setName("GitHub Gist ID").setDesc("This is the unique ID to the Gist that you created in GitHub").addText(
        (text) => text.setValue(settings.githubGistId).onChange(async (value) => {
          settings.githubGistId = value;
        })
      );
      new import_obsidian6.Setting(containerEl).setName("GitHub username").setDesc("This is only used to generate the URL to your calendar").addText(
        (text) => text.setValue(settings.githubUsername).onChange(async (value) => {
          settings.githubUsername = value;
        })
      );
      new import_obsidian6.Setting(containerEl).setName("Filename").setDesc("Give your calendar a file name").addText(
        (text) => text.setValue(settings.filename).setPlaceholder("obsidian.ics").onChange(async (value) => {
          settings.filename = value;
        })
      );
      const url = `https://gist.githubusercontent.com/${settings.githubUsername}/${settings.githubGistId}/raw/${settings.filename}`;
      new import_obsidian6.Setting(containerEl).setName("Your calendar URL").setDesc(createFragment((fragment) => {
        fragment.createEl("a", { text: url, href: url, cls: "search-result" });
      })).addButton((button) => {
        button.setButtonText("\u{1F4CB} Copy to clipboard").onClick(() => {
          navigator.clipboard.writeText(url);
          button.setButtonText("\u2705 Copied!");
          window.setTimeout(() => {
            button.setButtonText("\u{1F4CB} Copy to clipboard");
          }, 500);
        });
      });
    }
    if (settings.isSaveToFileEnabled) {
      containerEl.createEl("h3", { text: "Local File Settings" });
      if (settings.saveFileName === DEFAULT_SETTINGS.saveFileName) {
        settings.saveFileName = this.app.vault.getName();
        this.display();
      }
      new import_obsidian6.Setting(containerEl).setName("Path").setDesc("Which directory/folder do you want to save your calendar to? An empty string means to the current vault root path. The path must be inside the vault.").addText(
        (text) => text.setValue(settings.savePath).onChange(async (value) => {
          settings.savePath = value;
        })
      );
      new import_obsidian6.Setting(containerEl).setName("Filename").setDesc("What do you want to call the file of your calendar? An empty string means " + this.app.vault.getName()).addText(
        (text) => {
          var _a2;
          return text.setPlaceholder(this.app.vault.getName()).setValue((_a2 = settings.saveFileName) != null ? _a2 : this.app.vault.getName()).onChange(async (value) => {
            settings.saveFileName = value;
          });
        }
      );
      new import_obsidian6.Setting(containerEl).setName("File extension").setDesc("The file extension must be one of .ical or .ics or .ifb or .icalendar").addDropdown(
        (dropdown) => dropdown.addOptions({
          ".ics": ".ics",
          ".ical": ".ical",
          ".ifb": ".ifb",
          ".icalendar": ".icalendar"
        }).setValue(settings.saveFileExtension).onChange(async (value) => {
          settings.saveFileExtension = value;
          this.display();
        })
      );
      const savePath = `${(_a = settings.savePath) != null ? _a : settings.savePath + path.sep}${settings.saveFileName}${settings.saveFileExtension}`;
      new import_obsidian6.Setting(containerEl).setName("Your calendar path").setDesc(createFragment((fragment) => {
        fragment.createEl("a", { text: savePath, href: `file:///${savePath}`, cls: "search-result" });
      })).addButton((button) => {
        button.setButtonText("\u{1F4CB} Copy to clipboard").onClick(() => {
          navigator.clipboard.writeText(savePath);
          button.setButtonText("\u2705 Copied!");
          window.setTimeout(() => {
            button.setButtonText("\u{1F4CB} Copy to clipboard");
          }, 500);
        });
      });
    }
    containerEl.createEl("h2", { text: "Troubleshooting" });
    new import_obsidian6.Setting(containerEl).setName("Debug mode").setDesc("Turning this on will write logs to console.").addToggle(
      (toggle) => toggle.setValue(settings.isDebug).onChange(async (value) => {
        settings.isDebug = value;
        this.display();
      })
    );
  }
  validateGithubPersonalAccessToken(value) {
    const githubClassicPersonalAccessTokenRegex = /^ghp_[a-zA-Z0-9]{36}$/;
    const githubFineGrainedPersonalAccessTokenRegex = /^github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}$/;
    if (new RegExp(githubClassicPersonalAccessTokenRegex).test(value) || new RegExp(githubFineGrainedPersonalAccessTokenRegex).test(value)) {
      return;
    }
    throw new Error('GitHub Personal Access Token must start in "ghp_" for classic tokens or "github_pat_" for fine-grained tokens.');
  }
  // Replace multiple whitespace characters with a single space
  cleanTags(value) {
    return value.replace(/\s+/g, " ");
  }
};

// src/ObsidianIcalPlugin.ts
var ObsidianIcalPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await initSettingsManager(this);
    logger(settings.isDebug);
    log("SettingsManager and Logger initialised");
    this.addSettingTab(new SettingTab(this.app, this));
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  // Once the Obsidian layout is ready, kick off a scan and configure periodic save
  async onLayoutReady() {
    this.main = new Main(this.app);
    await this.main.start();
    await this.configurePeriodicSave();
    await this.configureValidationRefresh();
  }
  onunload() {
    this.clearPeriodicSaveInterval();
    this.clearValidationRefreshInterval();
  }
  clearPeriodicSaveInterval() {
    var _a;
    window.clearInterval((_a = this.periodicSaveInterval) != null ? _a : 0);
    this.periodicSaveInterval = null;
  }
  clearValidationRefreshInterval() {
    var _a;
    window.clearInterval((_a = this.validationRefreshInterval) != null ? _a : 0);
    this.validationRefreshInterval = null;
  }
  // Trigger a save every now and then
  async configurePeriodicSave() {
    this.clearPeriodicSaveInterval();
    if (settings.isPeriodicSaveEnabled && settings.periodicSaveInterval > 0) {
      log(`Periodic save enabled and will run every ${settings.periodicSaveInterval} minute(s)`);
      this.periodicSaveInterval = window.setInterval(async () => {
        log(`Periodic save triggers every ${settings.periodicSaveInterval} minute(s)`);
        await this.main.start();
      }, settings.periodicSaveInterval * 1e3 * 60);
      this.registerInterval(this.periodicSaveInterval);
    }
  }
  // Refresh validation cache every 5 minutes when web save is enabled
  async configureValidationRefresh() {
    this.clearValidationRefreshInterval();
    if (settings.isSaveToWebEnabled && settings.secretKey) {
      log("Validation refresh enabled and will run every 5 minute");
      this.validationRefreshInterval = window.setInterval(async () => {
        log("Validation refresh triggered - refreshing validation cache");
        try {
          await this.main.apiClient.isActive(true);
        } catch (error) {
          log("Validation refresh failed:", error);
        }
      }, 5 * 60 * 1e3);
      this.registerInterval(this.validationRefreshInterval);
    }
  }
};

/* nosourcemap */